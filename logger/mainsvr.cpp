// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -O. ../logger.ridl 
#include "rpc.h"
#include "proxy.h"
using namespace rpcf;
#include "LogServicesvr.h"
#include "csignal"
#include <pwd.h>
#include <sys/stat.h>

ObjPtr g_pIoMgr;

namespace rpcf
{

FactoryPtr InitClassFactory()
{
    BEGIN_FACTORY_MAPS;

    INIT_MAP_ENTRYCFG( CLogService_SvrImpl );
    
    END_FACTORY_MAPS;
}

extern "C"
gint32 DllLoadFactory( FactoryPtr& pFactory )
{
    pFactory = InitClassFactory();
    if( pFactory.IsEmpty() )
        return -EFAULT;
    return STATUS_SUCCESS;
}

gint32 InitContext()
{
    gint32 ret = CoInitialize( 0 );
    if( ERROR( ret ) )
        return ret;
    do{
        // load class factory for 'logger'
        FactoryPtr p = InitClassFactory();
        ret = CoAddClassFactory( p );
        if( ERROR( ret ) )
            break;
        
        CParamList oParams;
        oParams.Push( "loggersvr" );
        oParams.SetStrProp(
            propConfigPath, "loggerdrv.json" );

        // adjust the thread number if necessary
        oParams[ propMaxIrpThrd ] = 0;
        oParams[ propMaxTaskThrd ] = 4;
        
        ret = g_pIoMgr.NewObj(
            clsid( CIoManager ), 
            oParams.GetCfg() );
        if( ERROR( ret ) )
            break;

        CIoManager* pSvc = g_pIoMgr;
        ret = pSvc->Start();
        if( ERROR( ret ) )
            break;
        
        
    }while( 0 );

    return ret;
}

gint32 DestroyContext()
{
    IService* pSvc = g_pIoMgr;
    if( pSvc != nullptr )
    {
        pSvc->Stop();
        g_pIoMgr.Clear();
    }

    CoUninitialize();
    DebugPrintEx( logErr, 0,
        "#Leaked objects is %d",
        CObjBase::GetActCount() );
    return STATUS_SUCCESS;
}
}

using namespace rpcf;

gint32 mainsvr( CLogService_SvrImpl* pIf, int argc, char** argv );

static bool g_bDaemon = false;
static std::atomic<bool> g_bExit={ false };
stdstr g_strFile = "";

void Usage( char* szName )
{
    fprintf( stderr,
        "Usage: %s <option>\n"
        "\t [ -O <path> to output log to the file at given 'path' ]\n"
        "\t [ -d to run as a daemon ]\n"
        "\t [ -v version information ]\n"
        "\t [ -h this help ]\n",
        szName );
}

void signal_term_handler( int signal )
{
    g_bExit = true;
}

static gint32 IsValidFile( const char* szPath )
{
    gint32 ret = 0;
    do{
        STMPTR pFile = STMPTR(
            new std::ofstream( szPath,
            std::ofstream::out |
            std::ofstream::app ) );

        if( pFile->fail() )
            ret = -errno;

    }while( 0 );
    return ret;
}

static gint32 GetDefLogFile( stdstr& strFile )
{
    gint32 ret = 0;
    stdstr strPath;
    do{
        struct passwd* pw = getpwuid( getuid() );
        strPath = pw->pw_dir;
        strPath += "/.rpcf";
        ret = access( strPath.c_str(), F_OK );
        if( ret == -1 && errno == ENOENT )
        {
            ret = mkdir( strPath.c_str(), 0700 );
            if( ret == -1 )
            {
                ret = -errno;
                DebugPrintEx( logErr, ret, 
                    "Error unable to create directory '.rpcf'" );
                break;
            }
        }
        else if( ret == -1 )
        {
            ret = -errno;
            break;
        }
        strPath += "/log.txt";
    }while( 0 );

    if( ERROR( ret ) )
        strPath = "";

    return ret;
}

int main( int argc, char** argv )
{
    gint32 ret = 0;

    int opt = 0;
    bool bRole = false;
    stdstr strLogFile;
    while( ( opt = getopt( argc, argv, "O:hdv" ) ) != -1 )
    {
        switch (opt)
        {
        case 'O':
            {
                ret = IsValidFile( optarg );
                if( ERROR( ret ) )
                {
                    printf( "%s : %s\n", optarg,
                        strerror( -ret ) );
                    break;
                }
                strLogFile = optarg;
                break;
            }
        case 'd':
            {
                g_bDaemon = true;
                break;
            }
        case 'h':
            {
                Usage( argv[ 0 ] );
                exit( 0 );
            }
        case 'v':
            {
                fprintf( stdout, "%s", Version() );
                exit( 0 );
            }
        default: /*  '?' */
            ret = -EINVAL;
            break;
        }

        if( ERROR( ret ) )
            break;
    }

    if( ERROR( ret ) )
    {
        Usage( argv[ 0 ] );
        exit( -ret );
    }

    if( g_bDaemon )
        daemon( 1, 0 );

     std::signal( SIGTERM, signal_term_handler );

    do{
        std::string strDesc = "./loggerdesc.json";
        ret = InitContext();
        if( ERROR( ret ) )
            break;
        if( strLogFile.empty() )
        {
            ret = GetDefLogFile( strLogFile );
            if( ERROR( ret ) )
                break;
        }
        CRpcServices* pSvc = nullptr;
        InterfPtr pIf;
        do{
            CParamList oParams;

            oParams[ propIoMgr ] = g_pIoMgr;
            oParams[ propFilePath ] = strLogFile;
            
            ret = CRpcServices::LoadObjDesc(
                strDesc, "LogService",
                true, oParams.GetCfg() );
            if( ERROR( ret ) )
                break;
            ret = pIf.NewObj(
                clsid( CLogService_SvrImpl ),
                oParams.GetCfg() );
            if( ERROR( ret ) )
                break;
            pSvc = pIf;
            ret = pSvc->Start();
            if( ERROR( ret ) )
                break;
            if( pSvc->GetState()!= stateConnected )
            {
                ret = ERROR_STATE;
                break;
            }
        }while( 0 );
        
        CIoManager* pMgr = g_pIoMgr;
        CLogService_SvrImpl* pLogSvc = pIf;

        if( SUCCEEDED( ret ) )
        {
            stdstr strFile = "[";
            strFile += pMgr->GetModName() + "][INFO] ";
            strFile += __FILE__;
            stdstr strMsg = DebugMsgEx( strFile.c_str(),
                __LINE__, 0, "Logger started successfully" );
            pLogSvc->LogMessage( strMsg );
            ret = mainsvr( pIf, argc, argv );
        }
            
        // Stopping the object
        if( !pIf.IsEmpty() )
        {
            pIf->Stop();
            stdstr strFile = "[";
            strFile += pMgr->GetModName() + "][INFO] ";
            strFile += __FILE__;
            stdstr strMsg = DebugMsgEx( strFile.c_str(),
                __LINE__, 0, "Logger stopped" );
            pLogSvc->LogMessage( strMsg );
        }
    }while( 0 );

    DestroyContext();
    return ret;
}

//-----Your code begins here---
gint32 mainsvr( CLogService_SvrImpl* pIf, int argc, char** argv )
{
    gint32 ret = 0;
    // replace 'sleep' with your code for
    // advanced control
    while( pIf->IsConnected() && !g_bExit )
        sleep( 1 );
    ret = STATUS_SUCCESS;
    return ret;
}

