// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -lO. logger.ridl 
// Implement the following methods
// to get the RPC proxy/server work
#include "rpc.h"
#include "logger.h"
#include "LogServicesvr.h"
#include <limits.h>

namespace rpcf
{

CLogService_SvrImpl::CLogService_SvrImpl(
    const IConfigDb* pCfg ) :
    super::virtbase( pCfg ), super( pCfg )
{
    gint32 ret = 0;
    do{
        SetClassId( clsid(CLogService_SvrImpl ) );
        CCfgOpener oCfg( pCfg );

        ret = oCfg.GetStrProp(
            propFilePath, m_strPath );
        if( ERROR( ret ) )
            break;

        m_pFile = STMPTR(
            new std::ofstream( m_strPath,
            std::ofstream::out |
            std::ofstream::app ) );

        if( !m_pFile->is_open() )
        {
            DebugPrintEx( logErr, ret, 
                "Error unable to open log file %s",
                m_strPath.c_str() );
            ret = -EBADF;
        }

    }while( 0 );
    if( ERROR( ret ) )
    {
        stdstr strMsg = DebugMsg( ret,
            "Error in CLogService_SvrImpl ctor" );
        throw std::runtime_error( strMsg );
    }
    return;
}

// LogSvc Server
/* Sync Req Handler*/
gint32 CLogService_SvrImpl::DebugLog(
    const std::string& strMsg /*[ In ]*/ )
{
    // TODO: Process the sync request here 
    // return code can be an Error or
    // STATUS_SUCCESS
    return ERROR_NOT_IMPL;
}

/* Sync Req Handler*/
gint32 CLogService_SvrImpl::LogMessage(
    const std::string& strMsg /*[ In ]*/ )
{
    // TODO: Process the sync request here 
    // return code can be an Error or
    // STATUS_SUCCESS
    CStdRMutex oLock( this->GetLock() );
    ( *m_pFile )<< strMsg << "\n";
    return 0;
}

/* Async Req Handler*/
gint32 CLogService_SvrImpl::LogCritMsg(
    IConfigDb* pReqCtx_,
    const std::string& strMsg /*[ In ]*/ )
{
    // TODO: Emitting an async operation here.
    // And make sure to call LogCritMsgComplete
    // when the service is done
    CStdRMutex oLock( this->GetLock() );
    ( *m_pFile )<< strMsg << "\n";
    return 0;
}
gint32 CLogService_SvrImpl::TimerCallback(
    IEventSink* pCb, IConfigDb* pReqCtx )
{

    CStdRMutex oLock( this->GetLock() );
    m_pFile->flush();
    CParamList oReqCtx;
    gint32 ret = 0;
    m_pTimer = ADD_TIMER( this,
        oReqCtx.GetCfg(), 30,
        &CLogService_SvrImpl::TimerCallback );
    return ret;
}

gint32 CLogService_SvrImpl::StartFlushTask()
{
    gint32 ret = 0;
    do{
        CParamList oReqCtx;
        IConfigDb* pReqCtx = oReqCtx.GetCfg();
        m_pTimer = ADD_TIMER( this, pReqCtx, 30,
            &CLogService_SvrImpl::TimerCallback );
            
    }while( 0 );
    return ret;
}

gint32 CAsyncLoggerAMCallbacks::GetPointValuesToUpdate(
    InterfPtr& pIf,
    std::vector< KeyValue >& veckv )
{
    gint32 ret = 0;
    do{
        CInterfaceServer* pSvr = pIf;
        if( pSvr == nullptr )
        {
            ret = -EINVAL;
            break;
        }
        KeyValue okv;

        okv.strKey = O_VMSIZE_KB;
        okv.oValue = GetVmSize();
        veckv.push_back( okv );

        okv.strKey = O_OBJ_COUNT;
        okv.oValue = CObjBase::GetActCount();
        veckv.push_back( okv );

        okv.strKey = O_PENDINGS;
        ret = pIf->GetProperty(
            propPendingTasks, okv.oValue );
        if( SUCCEEDED( ret ) )
            veckv.push_back( okv );

        CStatCountersServer* pscs = pIf;
        okv.strKey = O_FAIL_COUNT;
        guint32 dwVal = 0;
        ret = pscs->GetCounter2(
            propFailureCount, dwVal );
        if( SUCCEEDED( ret ) )
        {
            okv.oValue = dwVal;
            veckv.push_back( okv );
        }

        okv.strKey = O_REQ_COUNT;
        ret = pscs->GetCounter2(
            propMsgCount, dwVal );
        if( SUCCEEDED( ret ) )
        {
            okv.oValue = dwVal;
            veckv.push_back( okv );
        }

        okv.strKey = O_RESP_COUNT;
        ret = pscs->GetCounter2(
            propMsgRespCount, dwVal );
        if( SUCCEEDED( ret ) )
        {
            okv.oValue = dwVal;
            veckv.push_back( okv );
        }

        okv.strKey = O_CPU_LOAD;
        okv.oValue = GetCpuUsage();
        veckv.push_back( okv );

        okv.strKey = O_OPEN_FILES;
        guint32 dwCount = 0;
        ret = GetOpenFileCount(
            getpid(), dwCount );
        if( SUCCEEDED( ret ) )
        {
            okv.oValue = dwCount;
            veckv.push_back( okv );
        }

        okv.strKey = O_UPTIME;
        timespec ts = pSvr->GetStartTime();
        timespec ts2;
        ret = clock_gettime( CLOCK_REALTIME, &ts2 );
        if( SUCCEEDED( ret ) )
        {
            guint32 dwUptime =
                ts2.tv_sec - ts.tv_sec;
            okv.oValue = dwUptime;
            veckv.push_back( okv );
        }
        ret = 0;
    }while( 0 );
    return ret;
}

gint32 CAsyncLoggerAMCallbacks::GetPointValuesToInit(
    InterfPtr& pIf,
    std::vector< KeyValue >& veckv )
{
    return super::GetPointValuesToInit( pIf, veckv );
}

}
