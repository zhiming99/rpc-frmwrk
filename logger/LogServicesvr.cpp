// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -lO. logger.ridl 
// Implement the following methods
// to get the RPC proxy/server work
#include "rpc.h"
#include "logger.h"
#include "LogServicesvr.h"
#include <limits.h>
#include <sstream>
using namespace rpcf;
extern bool g_bMonitoring; 

namespace rpcf
{

CLogService_SvrImpl::CLogService_SvrImpl(
    const IConfigDb* pCfg ) :
    super::virtbase( pCfg ), super( pCfg )
{
    gint32 ret = 0;
    do{
        SetClassId( clsid(CLogService_SvrImpl ) );
        CCfgOpener oCfg( pCfg );

        ret = oCfg.GetStrProp(
            propFilePath, m_strPath );
        if( ERROR( ret ) )
            break;

        m_pFile = STMPTR(
            new std::ofstream( m_strPath,
            std::ofstream::out |
            std::ofstream::app ) );

        if( !m_pFile->is_open() )
        {
            DebugPrintEx( logErr, ret, 
                "Error unable to open log file %s",
                m_strPath.c_str() );
            ret = -EBADF;
        }

    }while( 0 );
    if( ERROR( ret ) )
    {
        stdstr strMsg = DebugMsg( ret,
            "Error in CLogService_SvrImpl ctor" );
        throw std::runtime_error( strMsg );
    }
    return;
}

// LogSvc Server
/* Sync Req Handler*/
gint32 CLogService_SvrImpl::DebugLog(
    const std::string& strMsg /*[ In ]*/ )
{
    // TODO: Process the sync request here 
    // return code can be an Error or
    // STATUS_SUCCESS
    return ERROR_NOT_IMPL;
}

/* Sync Req Handler*/
gint32 CLogService_SvrImpl::LogMessage(
    const std::string& strMsg /*[ In ]*/ )
{
    // TODO: Process the sync request here 
    // return code can be an Error or
    // STATUS_SUCCESS
    CStdRMutex oLock( this->GetLock() );
    ( *m_pFile )<< strMsg << "\n";
    return 0;
}

/* Async Req Handler*/
gint32 CLogService_SvrImpl::LogCritMsg(
    IConfigDb* pReqCtx_,
    const std::string& strMsg /*[ In ]*/ )
{
    // TODO: Emitting an async operation here.
    // And make sure to call LogCritMsgComplete
    // when the service is done
    CStdRMutex oLock( this->GetLock() );
    ( *m_pFile )<< strMsg << "\n";
    return 0;
}

#define READBLK_SIZE 8192
gint32 CLogService_SvrImpl::TimerCallback(
    IEventSink* pCb, IConfigDb* pReqCtx )
{
    gint32 ret = 0;
    CStdRMutex oLock( this->GetLock() );
    m_pFile->flush();
    CParamList oReqCtx;
    m_pTimer = ADD_TIMER( this,
        oReqCtx.GetCfg(), 30,
        &CLogService_SvrImpl::TimerCallback );
    oLock.Unlock();

    if( !g_bMonitoring )
        return 0;

    InterfPtr pCli;
    ret = GetAppManagercli( pCli );
    if( ERROR( ret ) )
        return 0;

    std::ostringstream ss;
    ss << "tail -n " << this->m_dwLines
        << " " << this->m_strPath;
    FILE* pipe = popen( ss.str().c_str(), "r" );
    if( pipe == nullptr )
        return 0;

    BufPtr pBuf( true );
    pBuf->Resize( READBLK_SIZE );
    size_t dwOffset = 0;
    do{
        size_t ret = 0;
        ret = fread( pBuf->ptr() + dwOffset,
            1, READBLK_SIZE, pipe );
        dwOffset += ret;
        if( ret == READBLK_SIZE )
        {
            pBuf->Resize(
                dwOffset + READBLK_SIZE );
            continue;
        }
        pBuf->Resize( dwOffset );
        break;
    }while( true );
    pclose( pipe );
    if( pBuf->empty() )
        return 0;

    CAppManager_CliImpl* pam = pCli;
    CCfgOpener oContext;

    pam->SetLargePointValue( oContext.GetCfg(),
        LOGGER_APPNAME "/" LOGPT_LOGCONTENT, 
        pBuf );
    
    return 0;
}

gint32 CLogService_SvrImpl::StartFlushTask()
{
    gint32 ret = 0;
    do{
        CParamList oReqCtx;
        IConfigDb* pReqCtx = oReqCtx.GetCfg();
        m_pTimer = ADD_TIMER( this, pReqCtx, 30,
            &CLogService_SvrImpl::TimerCallback );
            
    }while( 0 );
    return ret;
}

gint32 CLogService_SvrImpl::SetProperty(
    gint32 iProp, const Variant& oVar )
{
    if( iProp == propLinesToShow )
    {
        m_dwLines = oVar;
        return 0;
    }
    return super::SetProperty( iProp, oVar );
}

gint32 CLogService_SvrImpl::GetProperty(
    gint32 iProp, Variant& oVar ) const
{
    if( iProp == propLinesToShow )
    {
        oVar = m_dwLines;
        return 0;
    }
    return super::GetProperty( iProp, oVar );
}


gint32 CAsyncLoggerAMCallbacks::GetPointValuesToUpdate(
    InterfPtr& pIf,
    std::vector< KeyValue >& veckv )
{
    gint32 ret = 0;
    do{
        CInterfaceServer* pSvr = pIf;
        if( pSvr == nullptr )
        {
            ret = -EINVAL;
            break;
        }
        KeyValue okv;

        okv.strKey = O_VMSIZE_KB;
        okv.oValue = GetVmSize();
        veckv.push_back( okv );

        okv.strKey = O_OBJ_COUNT;
        okv.oValue = CObjBase::GetActCount();
        veckv.push_back( okv );

        okv.strKey = O_PENDINGS;
        ret = pIf->GetProperty(
            propPendingTasks, okv.oValue );
        if( SUCCEEDED( ret ) )
            veckv.push_back( okv );

        CStatCountersServer* pscs = pIf;
        okv.strKey = O_FAIL_COUNT;
        guint32 dwVal = 0;
        ret = pscs->GetCounter2(
            propFailureCount, dwVal );
        if( SUCCEEDED( ret ) )
        {
            okv.oValue = dwVal;
            veckv.push_back( okv );
        }

        okv.strKey = O_REQ_COUNT;
        ret = pscs->GetCounter2(
            propMsgCount, dwVal );
        if( SUCCEEDED( ret ) )
        {
            okv.oValue = dwVal;
            veckv.push_back( okv );
        }

        okv.strKey = O_RESP_COUNT;
        ret = pscs->GetCounter2(
            propMsgRespCount, dwVal );
        if( SUCCEEDED( ret ) )
        {
            okv.oValue = dwVal;
            veckv.push_back( okv );
        }

        okv.strKey = O_CPU_LOAD;
        okv.oValue = GetCpuUsage();
        veckv.push_back( okv );

        okv.strKey = O_OPEN_FILES;
        guint32 dwCount = 0;
        ret = GetOpenFileCount(
            getpid(), dwCount );
        if( SUCCEEDED( ret ) )
        {
            okv.oValue = dwCount;
            veckv.push_back( okv );
        }

        okv.strKey = O_UPTIME;
        timespec ts = pSvr->GetStartTime();
        timespec ts2;
        ret = clock_gettime( CLOCK_REALTIME, &ts2 );
        if( SUCCEEDED( ret ) )
        {
            guint32 dwUptime =
                ts2.tv_sec - ts.tv_sec;
            okv.oValue = dwUptime;
            veckv.push_back( okv );
        }
        ret = 0;
    }while( 0 );
    return ret;
}

gint32 CAsyncLoggerAMCallbacks::GetPointValuesToInit(
    InterfPtr& pIf,
    std::vector< KeyValue >& veckv )
{
    return super::GetPointValuesToInit( pIf, veckv );
}

gint32 CAsyncLoggerAMCallbacks::ClaimAppInstCallback(
    IConfigDb* context, 
    gint32 iRet,
    std::vector<KeyValue>& arrPtToGet /*[ In ]*/ )
{
    gint32 ret = 0;
    do{
        if( ERROR( iRet ) )
        {
            ret = iRet;
            break;
        }
        for( auto& kv : arrPtToGet )
        {
            if( kv.strKey == LOGPT_LINES )
            {
                m_pIf->SetProperty(
                    propLinesToShow, kv.oValue );
                break;
            }
        }
    }while( 0 );
    ret = super::ClaimAppInstCallback(
        context, iRet, arrPtToGet );
    return ret;
}

gint32 CAsyncLoggerAMCallbacks::OnPointChanged(
    IConfigDb* context, 
    const std::string& strPtPath /*[ In ]*/,
    const Variant& value /*[ In ]*/ )
{
    gint32 ret = 0;
    do{
        if( strPtPath ==
            LOGGER_APPNAME "/" LOGPT_LINES )
        {
            guint32 dwLines = value;
            if( dwLines > 10000 )
                break;
            ret = m_pIf->SetProperty(
                propLinesToShow, value );
            break;
        }
        ret = super::OnPointChanged(
            context, strPtPath, value );
    }while( 0 );
    return ret;
}

}
