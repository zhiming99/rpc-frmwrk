// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -lO. logger.ridl 
// Implement the following methods
// to get the RPC proxy/server work
#include "rpc.h"
#include "logger.h"
#include "LogServicesvr.h"

namespace rpcf
{

CLogService_SvrImpl::CLogService_SvrImpl(
    const IConfigDb* pCfg ) :
    super::virtbase( pCfg ), super( pCfg )
{
    gint32 ret = 0;
    do{
        SetClassId( clsid(CLogService_SvrImpl ) );
        CCfgOpener oCfg( pCfg );

        ret = oCfg.GetStrProp(
            propFilePath, m_strPath );
        if( ERROR( ret ) )
            break;

        m_pFile = STMPTR(
            new std::ofstream( m_strPath,
            std::ofstream::out |
            std::ofstream::app ) );

        if( !m_pFile->is_open() )
        {
            DebugPrintEx( logErr, ret, 
                "Error unable to open log file %s",
                m_strPath.c_str() );
            ret = -EBADF;
        }

    }while( 0 );
    if( ERROR( ret ) )
    {
        stdstr strMsg = DebugMsg( ret,
            "Error in CLogService_SvrImpl ctor" );
        throw std::runtime_error( strMsg );
    }
    return;
}

// LogSvc Server
/* Sync Req Handler*/
gint32 CLogService_SvrImpl::DebugLog(
    const std::string& strMsg /*[ In ]*/ )
{
    // TODO: Process the sync request here 
    // return code can be an Error or
    // STATUS_SUCCESS
    return ERROR_NOT_IMPL;
}

/* Sync Req Handler*/
gint32 CLogService_SvrImpl::LogMessage(
    const std::string& strMsg /*[ In ]*/ )
{
    // TODO: Process the sync request here 
    // return code can be an Error or
    // STATUS_SUCCESS
    CStdRMutex oLock( this->GetLock() );
    ( *m_pFile )<< strMsg << "\n";
    return 0;
}

/* Async Req Handler*/
gint32 CLogService_SvrImpl::LogCritMsg(
    IConfigDb* pReqCtx_,
    const std::string& strMsg /*[ In ]*/ )
{
    // TODO: Emitting an async operation here.
    // And make sure to call LogCritMsgComplete
    // when the service is done
    CStdRMutex oLock( this->GetLock() );
    ( *m_pFile )<< strMsg << "\n";
    return 0;
}
gint32 CLogService_SvrImpl::TimerCallback(
    IEventSink* pCb, IConfigDb* pReqCtx )
{

    CStdRMutex oLock( this->GetLock() );
    m_pFile->flush();
    CParamList oReqCtx;
    gint32 ret = 0;
    m_pTimer = ADD_TIMER( this,
        oReqCtx.GetCfg(), 30,
        &CLogService_SvrImpl::TimerCallback );
    return ret;
}

gint32 CLogService_SvrImpl::StartFlushTask()
{
    gint32 ret = 0;
    do{
        CParamList oReqCtx;
        IConfigDb* pReqCtx = oReqCtx.GetCfg();
        m_pTimer = ADD_TIMER( this, pReqCtx, 30,
            &CLogService_SvrImpl::TimerCallback );
            
    }while( 0 );
    return ret;
}

}
