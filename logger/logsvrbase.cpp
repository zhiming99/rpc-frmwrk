// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -lO. logger.ridl 
#include "rpc.h"
#include "iftasks.h"
#include "logsvrbase.h"

namespace rpcf
{

gint32 ILogSvc_SImpl::InitUserFuncs()
{
    BEGIN_IFHANDLER_MAP( LogSvc );

    ADD_USER_SERVICE_HANDLER(
        ILogSvc_SImpl::DebugLogWrapper,
        "DebugLog" );
    
    ADD_USER_SERVICE_HANDLER(
        ILogSvc_SImpl::LogMessageWrapper,
        "LogMessage" );
    
    ADD_USER_SERVICE_HANDLER(
        ILogSvc_SImpl::LogCritMsgWrapper,
        "LogCritMsg" );
    
    END_IFHANDLER_MAP;
    
    return STATUS_SUCCESS;
}

gint32 ILogSvc_SImpl::DebugLogWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strMsg;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strMsg );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = DebugLog(
        strMsg );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }
    return ret;
}

gint32 ILogSvc_SImpl::LogMessageWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strMsg;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strMsg );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = LogMessage(
        strMsg );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }
    return ret;
}

gint32 ILogSvc_SImpl::LogCritMsgWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    TaskletPtr pNewCb;
    do{
        ret = SetInvTimeout( pCallback, 0 );
        if( ERROR( ret ) ) break;
        CParamList oReqCtx_;
        oReqCtx_.SetPointer(
            propEventSink, pCallback );
        IConfigDb* pReqCtx_ = oReqCtx_.GetCfg();
        ret = DEFER_CANCEL_HANDLER2(
            -1, pNewCb, this,
            &ILogSvc_SImpl::LogCritMsgCancelWrapper,
            pCallback, 0, pReqCtx_, pBuf_ );
        
        if( ERROR( ret ) ) break;
        
        std::string strMsg;
        
        ObjPtr pDeserialIf_(this);
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.Deserialize(
                pBuf_, strMsg );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        ret = LogCritMsg(
            pReqCtx_,
            strMsg );
        
        if( ret == STATUS_PENDING ) break;
        
        CParamList oResp_;
        oResp_[ propReturnValue ] = ret;
        oResp_[ propSeriProto ] = seriRidl;
        
        this->SetResponse( pCallback,
            oResp_.GetCfg() );
        
    }while( 0 );
    
    if( ret != STATUS_PENDING &&
        !pNewCb.IsEmpty() )
    {
        CIfRetryTask* pTask = pNewCb;
        pTask->ClearClientNotify();
        if( pCallback != nullptr )
            rpcf::RemoveInterceptCallback(
                pTask, pCallback );
        ( *pNewCb )( eventCancelTask );
    }
    return ret;
}
// this method is called when
// timeout happens or user cancels
// this pending request
gint32 ILogSvc_SImpl::LogCritMsgCancelWrapper(
    IEventSink* pCallback,
    gint32 iRet,
    IConfigDb* pReqCtx_, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    do{
        std::string strMsg;
        
        ObjPtr pDeserialIf_(this);
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.Deserialize(
                pBuf_, strMsg );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        OnLogCritMsgCanceled( pReqCtx_,
            iRet,
            strMsg );
    }while( 0 );

    return ret;
}
// call me when you have completed
// the asynchronous operation
gint32 ILogSvc_SImpl::LogCritMsgComplete( 
    IConfigDb* pReqCtx_, gint32 iRet )
{
    gint32 ret = 0;
    IEventSink* pCallback = nullptr;
    CParamList oParams( pReqCtx_ );
    ret = oParams.GetPointer(
        propEventSink, pCallback );
    if( ERROR( ret ) )
        return ret;
    if( iRet == STATUS_PENDING )
        ret = ERROR_STATE;
    else
        ret = iRet;
    
    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->OnServiceComplete( 
        ( IConfigDb* )oResp_.GetCfg(), pCallback );
    return ret;
}

}
