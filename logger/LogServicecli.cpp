// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -lO. logger.ridl 
// Implement the following methods
// to get the RPC proxy/server work
#include "rpc.h"
#include "logger.h"
#include "LogServicecli.h"

namespace rpcf
{

FactoryPtr InitClassFactory()
{
    BEGIN_FACTORY_MAPS;

    INIT_MAP_ENTRYCFG( CLogService_CliImpl );
    
    END_FACTORY_MAPS;
}

extern "C"
gint32 DllLoadFactory( FactoryPtr& pFactory )
{
    pFactory = InitClassFactory();
    if( pFactory.IsEmpty() )
        return -EFAULT;
    return STATUS_SUCCESS;
}

gint32 CLogService_CliImpl::DebugLog(
    const std::string& strMsg )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "LogSvc" );
    oOptions_[ propNoReply ] = true;
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(this);
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strMsg );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "DebugLog", pBuf_ );
    
    return ret;
}

gint32 CLogService_CliImpl::LogMessage(
    const std::string& strMsg )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "LogSvc" );
    oOptions_[ propNoReply ] = true;
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(this);
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strMsg );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "LogMessage", pBuf_ );
    
    return ret;
}

gint32 CLogService_CliImpl::LogCritMsg(
    const std::string& strMsg )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "LogSvc" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(this);
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strMsg );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "LogCritMsg", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

}
