// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2025  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -O. logger.ridl 
#include "rpc.h"
#include "proxy.h"
using namespace rpcf;
#include "LogServicecli.h"
#include <getopt.h>

ObjPtr g_pIoMgr;

FactoryPtr InitClassFactory()
{
    BEGIN_FACTORY_MAPS;

    INIT_MAP_ENTRYCFG( CLogService_CliImpl );
    
    END_FACTORY_MAPS;
}

extern "C"
gint32 DllLoadFactory( FactoryPtr& pFactory )
{
    pFactory = InitClassFactory();
    if( pFactory.IsEmpty() )
        return -EFAULT;
    return STATUS_SUCCESS;
}

gint32 InitContext()
{
    gint32 ret = CoInitialize( 0 );
    if( ERROR( ret ) )
        return ret;
    do{
        // load class factory for 'logger'
        FactoryPtr p = InitClassFactory();
        ret = CoAddClassFactory( p );
        if( ERROR( ret ) )
            break;
        
        CParamList oParams;
        oParams.Push( "loggercli" );
        oParams.SetStrProp(
            propConfigPath, "loggerdrv.json" );

        // adjust the thread number if necessary
        oParams[ propMaxIrpThrd ] = 0;
        oParams[ propMaxTaskThrd ] = 1;
        
        ret = g_pIoMgr.NewObj(
            clsid( CIoManager ), 
            oParams.GetCfg() );
        if( ERROR( ret ) )
            break;

        CIoManager* pSvc = g_pIoMgr;
        ret = pSvc->Start();
        if( ERROR( ret ) )
            break;
    }while( 0 );

    return ret;
}

gint32 DestroyContext()
{
    IService* pSvc = g_pIoMgr;
    if( pSvc != nullptr )
    {
        pSvc->Stop();
        g_pIoMgr.Clear();
    }

    CoUninitialize();
    DebugPrintEx( logErr, 0,
        "#Leaked objects is %d",
        CObjBase::GetActCount() );
    return STATUS_SUCCESS;
}

gint32 maincli( CLogService_CliImpl* pIf, int argc, char** argv );

int main( int argc, char** argv )
{
    gint32 ret = 0;
    do{
        std::string strDesc =
            "invalidpath/loggerdesc.json";
        ret = InitContext();
        if( ERROR( ret ) )
            break;
        
        CRpcServices* pSvc = nullptr;
        InterfPtr pIf;
        do{
            CParamList oParams;
            oParams[ propIoMgr ] = g_pIoMgr;
            
            ret = CRpcServices::LoadObjDesc(
                strDesc, "LogService",
                false, oParams.GetCfg() );
            if( ERROR( ret ) )
                break;
            ret = pIf.NewObj(
                clsid( CLogService_CliImpl ),
                oParams.GetCfg() );
            if( ERROR( ret ) )
                break;
            pSvc = pIf;
            ret = pSvc->Start();
            if( ERROR( ret ) )
                break;
            while( pSvc->GetState()== stateRecovery )
                sleep( 1 );
            
            if( pSvc->GetState() != stateConnected )
            {
                ret = ERROR_STATE;
                break;
            }
        }while( 0 );
        
        if( SUCCEEDED( ret ) )
            ret = maincli( pIf, argc, argv );
            
        // Stopping the object
        if( !pIf.IsEmpty() )
            pIf->Stop();
    }while( 0 );

    DestroyContext();
    return ret;
}

static std::string DebugMsgInternal2(
    gint32 ret, const std::string& strMsg,
    const char* szFunc, gint32 iLineNum, guint32 dwPid )
{
    timespec ts = { 0 };
    clock_gettime( CLOCK_REALTIME, &ts );

    char szBuf[ 4096 ];
    szBuf[ sizeof( szBuf ) - 1 ] = 0;
    snprintf( szBuf,
        sizeof( szBuf ) - 1,
        "[%ld.%09ld-%d]%s(%d): %s(%d)",
        ts.tv_sec,
        ts.tv_nsec,
        dwPid,
        szFunc,
        iLineNum,
        strMsg.c_str(),
        ret );
    return std::string( szBuf );
}

stdstr BuildLogMsg(
    const stdstr& strType,
    const std::string& srcFile,
    gint32 iLineNum, 
    const stdstr& strMod,
    guint32 dwPid, 
    const std::string& strFmt,
    gint32 ret, ... )
{
    char szBuf[ 8192 ];
    if( strFmt.size() >= sizeof( szBuf ) )
        return "";

    gint32 iSize = sizeof( szBuf );
    szBuf[ iSize - 1 ] = 0;

    va_list argptr;
    va_start(argptr, ret );
    vsnprintf( szBuf, iSize - 1,
        strFmt.c_str(), argptr );
    va_end(argptr);

    stdstr strFile = "[";
    strFile += strMod + "][";
    strFile += strType + "] ";
    strFile += srcFile;

    return DebugMsgInternal2(
        ret, szBuf, strFile.c_str(),
        iLineNum, dwPid );
}

void Usage( char* szName )
{
    fprintf( stderr,
        "Usage: %s <option> <message>\n"
        "\t [ -t <msg type> one of the type [ EMERG | ALERT | CRITI | ERROR | "
        "WARN | NOTE | INFO ]\n"
        "\t [ -p <pid> logger's pid ]\n"
        "\t [ -f <file name> specify the soruce file name ]\n"
        "\t [ -l <line no> specify the line number in the soruce file ]\n"
        "\t [ -n <name> logger's name ]\n"
        "\t [ -v version information ]\n"
        "\t [ -h this help ]\n",
        szName );
}
const char* al[] = 
{
    "EMERG",
    "ALERT",
    "CRITI",
    "ERROR",
    "WARN",
    "NOTE", // = 5
    "INFO",
};

//-----Your code begins here---
gint32 maincli( CLogService_CliImpl* pIf, int argc, char** argv )
{
    gint32 ret = 0;
    stdstr strModule;
    stdstr strType;
    stdstr strSrcFile;
    guint32 dwPid = 0;
    guint32 iLineNo = 0;
    int opt = 0;
    while( ( opt = getopt( argc, argv, "l:f:t:p:n:vh" ) ) != -1 )
    {
        switch (opt)
        {
        case 'f':
            {
               strSrcFile = optarg;
               break;
            }
        case 'l':
            {
                iLineNo = std::strtol(
                    optarg, nullptr, 10 );
                break;
            }
        case 'n':
            {
                ret = IsValidName( optarg );
                if( ERROR( ret ) )
                {
                    printf( "%s : %s\n", optarg,
                        strerror( -ret ) );
                    break;
                }
                strModule = optarg;
                break;
            }
        case 'p':
            {
                dwPid = std::strtol(
                    optarg, nullptr, 10 );
                break;
            }
        case 't':
            {
                int i = 0;
                size_t count =
                    sizeof( al ) / sizeof( al[0] );
                for( ; i < count; i++ )
                {
                    ret = strcmp( optarg, al[ i ] );
                    if( ret != 0 )
                        continue;
                    break;
                }
                if( i == count )
                {
                    ret = -EINVAL;
                    fprintf( stderr,
                        "Invalid log type '%s'",
                        optarg );
                    break;
                }
                strType = optarg;
                break;
            }
        case 'h':
            {
                Usage( argv[ 0 ] );
                exit( 0 );
            }
        case 'v':
            {
                fprintf( stdout, "%s", Version() );
                exit( 0 );
            }
        default: /*  '?' */
            ret = -EINVAL;
            break;
        }

        if( ERROR( ret ) )
            break;
    }
    if( ERROR( ret ) )
        return ret;

    if( argv[ optind ] == nullptr )
    {
        fprintf( stderr,
            "Missing message to send\n" );
        Usage( argv[ 0 ] );
        return -ENOENT;
    }

    stdstr strText = argv[ optind ];

    if( dwPid == 0 )
        dwPid = getpid();
    if( strModule.empty() )
        strModule = "rpcf_sendlog";
    if( strType.empty() )
        strType = "INFO";

    if( iLineNo == 0 )
        iLineNo = __LINE__;
    if( strSrcFile.empty() )
        strSrcFile = __FILE__;
    stdstr strMsg = BuildLogMsg(
        strType, strSrcFile, iLineNo,
        strModule, dwPid, "%s",
        0, strText.c_str() );
    if( strMsg.empty() )
        return -ENODATA;
    pIf->LogMessage( strMsg );
    return STATUS_SUCCESS;
}

