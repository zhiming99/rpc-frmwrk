// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -lO. logger.ridl 
// Your task is to implement the following classes
// to get your rpc server work
#pragma once

#include <iostream>
#include <fstream>
#include "logsvrbase.h"

#include "rpc.h"
using namespace rpcf;
#include "stmport.h"
#include "fastrpc.h"

#include "AppManagercli.h"

#define  LOGPT_LINES_SHOW 100
#define  LOGGER_APPNAME "loggersvr1"
#define  LOGPT_LINES "lines"
#define  LOGPT_LOGCONTENT "logcontent"

namespace rpcf
{

enum EnumLogPropId : guint32
{
    propLinesToShow = propReservedEnd + 100,
};

struct CAsyncLoggerAMCallbacks :
    public CAsyncStdAMCallbacks
{
    typedef CAsyncStdAMCallbacks super;
    gint32 GetPointValuesToUpdate(
        InterfPtr& pIf,
        std::vector< KeyValue >& veckv ) override;

    gint32 GetPointValuesToInit(
        InterfPtr& pIf,
        std::vector< KeyValue >& veckv ) override;

    // RPC Async Req Callback
    gint32 ClaimAppInstCallback(
        IConfigDb* context, 
        gint32 iRet,
        std::vector<KeyValue>& arrPtToGet /*[ In ]*/ ) override;

    gint32 OnPointChanged( 
        IConfigDb* context, 
        const std::string& strPtPath /*[ In ]*/,
        const Variant& value /*[ In ]*/ ) override;
};

typedef std::unique_ptr< std::ofstream > STMPTR;
class CLogService_SvrImpl
    : public CLogService_SvrSkel
{
    protected:
    
    stdstr m_strPath;

    STMPTR  m_pFile;
    TaskletPtr m_pTimer;
    guint32 m_dwLines = LOGPT_LINES_SHOW;

    public:
    typedef CLogService_SvrSkel super;
    CLogService_SvrImpl( const IConfigDb* pCfg );

    gint32 InvokeUserMethod(
        IConfigDb* pParams,
        IEventSink* pCallback ) override
    {
        gint32 ret = AllocReqToken();
        if( ERROR( ret ) )
            return ret;
        return super::InvokeUserMethod(
            pParams, pCallback );
    }

    gint32 OnPostStart(
        IEventSink* pCallback ) override
    {
        StartQpsTask();
        gint32 ret = StartFlushTask();
        if( ERROR( ret ) )
            return ret;
        return super::OnPostStart( pCallback );
    }

    gint32 OnPreStop(
        IEventSink* pCallback ) override
    {
        if( true )
        {
            CStdRMutex oLock( GetLock() );
            if( m_pFile.get() != nullptr &&
                m_pFile->good() )
                m_pFile->flush();
                
            if( !m_pTimer.IsEmpty() )
                ( *m_pTimer )( eventCancelTask );
        }
        StopQpsTask();
        return super::OnPreStop( pCallback );
    }

    // LogSvc
    virtual gint32 DebugLog(
        const std::string& strMsg /*[ In ]*/ );
    
    virtual gint32 LogMessage(
        const std::string& strMsg /*[ In ]*/ );
    
    virtual gint32 LogCritMsg(
        IConfigDb* pReqCtx_,
        const std::string& strMsg /*[ In ]*/ );
    
    // RPC Async Req Cancel Handler
    // Rewrite this method to release the resources
    gint32 OnLogCritMsgCanceled(
        IConfigDb* pReqCtx,
        gint32 iRet,
        const std::string& strMsg /*[ In ]*/ )
    {
        DebugPrintEx( logErr, iRet,
            "request 'LogCritMsg' is canceled." );
        return 0;
    }

    gint32 SetProperty(
        gint32 iProp, const Variant& oVar ) override;

    gint32 GetProperty(
        gint32 iProp, Variant& oVar ) const override;

    gint32 StartFlushTask();
    gint32 TimerCallback( IEventSink*, IConfigDb* );

};

}
