// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -lO. logger.ridl 
// Your task is to implement the following classes
// to get your rpc server work
#pragma once

#include <iostream>
#include <fstream>
#include "logsvrbase.h"

#include "rpc.h"
using namespace rpcf;
#include "stmport.h"
#include "fastrpc.h"

#include "AppManagercli.h"

namespace rpcf
{

struct CAsyncLoggerAMCallbacks :
    public CAsyncStdAMCallbacks
{
    typedef CAsyncStdAMCallbacks super;
    gint32 GetPointValuesToUpdate(
        InterfPtr& pIf,
        std::vector< KeyValue >& veckv ) override;

    gint32 GetPointValuesToInit(
        InterfPtr& pIf,
        std::vector< KeyValue >& veckv ) override;
};

typedef std::unique_ptr< std::ofstream > STMPTR;
class CLogService_SvrImpl
    : public CLogService_SvrSkel
{
    protected:
    
    stdstr m_strPath;

    STMPTR  m_pFile;
    TaskletPtr m_pTimer;

    public:
    typedef CLogService_SvrSkel super;
    CLogService_SvrImpl( const IConfigDb* pCfg );

    gint32 InvokeUserMethod(
        IConfigDb* pParams,
        IEventSink* pCallback ) override
    {
        gint32 ret = AllocReqToken();
        if( ERROR( ret ) )
            return ret;
        return super::InvokeUserMethod(
            pParams, pCallback );
    }

    gint32 OnPostStart(
        IEventSink* pCallback ) override
    {
        StartQpsTask();
        gint32 ret = StartFlushTask();
        if( ERROR( ret ) )
            return ret;
        return super::OnPostStart( pCallback );
    }

    gint32 OnPreStop(
        IEventSink* pCallback ) override
    {
        if( true )
        {
            CStdRMutex oLock( GetLock() );
            if( m_pFile.get() != nullptr &&
                m_pFile->good() )
                m_pFile->flush();
                
            if( !m_pTimer.IsEmpty() )
                ( *m_pTimer )( eventCancelTask );
        }
        StopQpsTask();
        return super::OnPreStop( pCallback );
    }

    // LogSvc
    virtual gint32 DebugLog(
        const std::string& strMsg /*[ In ]*/ );
    
    virtual gint32 LogMessage(
        const std::string& strMsg /*[ In ]*/ );
    
    virtual gint32 LogCritMsg(
        IConfigDb* pReqCtx_,
        const std::string& strMsg /*[ In ]*/ );
    
    // RPC Async Req Cancel Handler
    // Rewrite this method to release the resources
    gint32 OnLogCritMsgCanceled(
        IConfigDb* pReqCtx,
        gint32 iRet,
        const std::string& strMsg /*[ In ]*/ )
    {
        DebugPrintEx( logErr, iRet,
            "request 'LogCritMsg' is canceled." );
        return 0;
    }

    gint32 StartFlushTask();
    gint32 TimerCallback( IEventSink*, IConfigDb* );

};

}
