[English](./Concept.md)

# rpc-frmwrk概念和技术介绍
RPC是英文Remote Procedure Call的简写。 `rpc-frmwrk`提供了一套运行库和接口API通过抽象，简化，自动化，和集成，封装了分布式应用程序传输层的接口，序列化，错误处理，传输，配置以及运行时监控等功能。接下来，面向基于`rpc-frmwrk`作开发的听众，介绍一些开发过程中会碰到的概念和设计思想。

## 设计思想
`rpc-frmwrk`设计上，首先是一个I/O系统。通过构建以`CRpcServices`-`CTaskGroup`-`CPort`为核心的一组对象，先行实现了I/O操作的的各种基本特性，如启停操作，超时管理，取消操作，任务间同步和协调，状态管理，异步调用，和生命周期管理等。然后反复使用这一模式，迭代出各种所需的功能。所以`rpc-frmwrk`理想进化模式可以向分形图案一样，不断演化进步。

## RPC参与方和传输的信息
服务器`Server`和代理`Proxy`是RPC通信中的必要的参与方。通信的一般的流程是，Proxy发出请求，叫做`Request`，Server响应请求，提供调用服务，发回结果`Response`，最后Proxy消费`Response`。Server有的时候也会主动的发出信息，叫做`Event`。Proxy发出的调用请求一般来说有明确的目的地，而且一般会有Server发出的`Response`作为响应。而Server主动发出的Event则是广播性质的，只要是订阅该事件的Proxy都会收到。不过`Event`也有特例，如`Keep-Alive`的消息是一对一的，不会广播发布。

同时也会有`Client`说法，因为`Proxy`在`rpc-frmwrk`的上下文中，指某一个接口的代理对象，而`Client`则泛指容纳一个或多个`Proxy`实例的对象或者应用程序。

## 远程调用(RPC), 进程间调用(IPC)和进程内调用(In-Process Call)
基于RPC-frmwrk的服务器可以同时支持这三种调用。如果服务器和客户端生成的是动态库，则只需改变配置即可完成RPC/IPC/In-Process的切换。

## 远程调用（RPC）和本地调用的区别
在分布式程序员的视角下，远程调用有以下特点
* 远程调用的发出和调用的发生是有延迟的，快的上百微秒，慢的几秒甚至几十秒。本地调用，这个延迟是几个指令周期。
* 远程调用的传输过程是不可靠的，有可能是服务器故障，网络连接中断，或者网络拥塞。本地调用则不存在上述问题。所以分布式程序员需要处理这些本地调用不存在的问题。
* 本地调用基本上是同步的调用。远程调用在内部实现上出于性能和健壮性的考虑，普遍是异步的（非阻塞的），但在接口上提供同步和异步两种接口。
* 显而易见的是开发过程中，实现远程调用的工作量比本地调用要大很多。

## 配置`rpc-frmwrk`
* `rpc-frmwrk`的每一对Server/Proxy共享一个`对象描述文件`，该文件给出连接服务器的各种参数，认证的用户信息，或者运行时的参数。除了此文件，还有一个`driver.json`配置的文件。`driver.json`给出的是Server/Proxy运行时依赖的`I/O子系统`配置信息。不用紧张，配置文件一般情况下可以通过配置工具和`ridlc`生成的Makefile搞定，若非高级配置，不需要手工设定。
* 关于配置工具的详细介绍，请参考这篇[文章](./tools/README_cn.md#rpc-frmwrk配置工具)。

## rpcrouter
* rpcrouter是`rpc-frmwrk`的关键组件。完成所有RPC相关的任务。rpcrouter在微服务模式下是独立的daemon程序。特别的，运行在服务器端的又称为`bridge`,
* 运行在客户端的叫`reqfwdr`。rpcrouter在紧凑模式下，以动态库的形式和用户代码合并，并运行在同一个进程中，以获得较好的性能。rpcrouter的任务包括，连接的建立的管理，传输协议的实现，认证授权流程，数据流的中继，级联(multihop)，流量控制，负载均衡，以及监测数据的记录和报告等RPC相关的任务。当用户的服务器和客户端都运行在一台主机上时，就不需要rpcrouter的参与了。有关rpcrouter的详细使用说明可以参看rpcrouter的[README](./rpc/router/README_cn.md). 当服务器和客户端运行在`紧凑模式`时，也不需要rpcrouter的参与。

## 同步，异步和回调函数
`rpc-frmwrk`的Proxy和Server的每个方法调用都可以指定是同步或者异步调用。
* 同步调用和我们平时调用函数一样，调用的线程会一直被阻塞(Blocked)，直到服务器返回结果，或者系统返回错误。此时需要查看返回值，确定调用是否成功。错误包括超时，或者队列满，或者被取消，或者其他的从服务器端返回的错误。

* 异步调用当请求被发出后，调用的线程会立刻返回，不等待服务器返回结果。此时调用者需要查看返回值，确定调用的状态是正在执行(STATUS_PENDING)，或者出错。如果是正在执行中，服务器的`Response`或者系统的错误，都会从回调函数中返回。异步调用在服务器端是有流量控制的，过多的未完成的异步调用会导致新的`Request`被拒绝(ERROR_QUEUE_FULL)，直到服务端有空闲的资源时，才能恢复。

* `rpc-frmwrk`在用户接口层提供基于回调函数的异步调用。如果一个rpc请求在`ridl`文件中被定义成异步的请求，`ridlc`可以自动生成必要的回调函数，简化开发过程，节省工作量。

## 事件和单程请求
* 事件是从服务器发送到客户端的消息，可以有广播型事件和单播型事件。事件没有同步和异步的概念，因为它不需要客户端返回响应消息。
* 单程请求(no-reply)是从客户端到服务器的请求，和普通请求的不同之处在于，它不需要服务器返回响应消息。客户端发送完请求消息，就立刻返回。如果客户端十分繁忙，有可能该请求会被放入等待队列，此时客户端的调用也有可能会被阻塞上一会，直到该请求被发出，或者出错。单程请求用于客户端不关心该请求是否能够被成功执行的应用场景。

## 任务(Tasklet)和任务组(TaskGroup)
* 任务(tasklet)源自于Linux kernel中的tasklet_struct，起初用于封装函数和函数的参数，随着开发的不断深入，任务(tasklet)也不断的添加新的功能，早已超过了tasklet的原始范畴，逐渐变成遍布`rpc-frmwrk`一个building-block。实际上，上面提到的回调函数就是由内部tasklet封装和调用的。`rpc-frmwrk`的任务(tasklet)主要包括以下的功能：
    * 封装一个函数或者一个方法和其参数
    * 跳出当前运行栈，预防死锁，或者避免调用栈嵌套过多。
    * 作为一个异步操作的发起者
    * 作为一个异步操作的Callback
    * 为一个异步操作设置定时器
    * 作为一个取消操作(Canceling)的最小单位
    * 在任务结束时，调用预设的外部Callback，和通知所隶属的TaskGroup.
* 任务组（TaskGroup），顾名思义，就是一组任务的集合。相当于在任务(tasklet)空间上的运算。任务组继承自任务，用作协调一组子任务的执行。这些子任务可以是并行，也可以是串行。串行时，任务组的执行逻辑可以是逻辑与，逻辑或，或者没有前后依赖关系，或者只是顺序的执行。串行执行的任务组还有另一个用处，就是同步。比起使用锁来进行同步，这个方法可以免去对关键数据上锁。由于任务组本身也是一个任务，所以它也具有任务(tasklet)所有的属性。
* 可以说，一个调用`Request`在`rpc-frmwrk`中的存在形式，就是一个前后串联的任务链。
* 熟悉JavaScript的同学，可以把`Tasklet`和`Promise`作个对比，有助于更好的理解`Tasklet`。两者有很多相似的地方，比如都是解决异步的执行的工具，都有状态的切换，都可以定制`callback`的函数，可以顺序执行，也可以并发执行，对返回结果约定，和出错的处理约定。当然也有很多的不同，比如`Tasklet`是运行在并发环境下，而`Promise`运行在单线程的环境中，`Tasklet`细分了`Timeout`和`Cancel`两种错误，而`Promise`统一为`reject`。`Tasklet`更直观一些，`Promise`则注重格式上的一致和优雅. 

## 取消一个RPC调用请求
* `rpc-frwmrk`允许用户取消一个还未完成的RPC调用请求，这个请求必须已被服务器端收到，并且在等待处理结果。
* 取消操作必须在异步模式下进行，也就是服务器端的`Request`处理和代理端的`Request`发送都是异步的，有一方处于同步操作的话，都不能进行取消操作，或者会失败。

## 服务器对象和对象的地址
`rpc-frmwrk`的服务器对象是一个继承自CInterfaceServer的对象，同时这个对象在DBus上进行了注册。由于DBus是`rpc-frmwrk`IPC通信的一个重要途径, 因此服务器对象的寻址中包含了`DBus`的地址信息。RPC通信地址则是在IPC地址的基础上，增加了网络地址信息。所以一个RPC服务对象的地址是一个五元组，{IP地址，TCP端口，路由器路径，对象路径，接口名称}。其中`路由器路径`请参考下面有关`multihop`的说明. `对象路径`和`接口名称`是DBus相关的信息。以上这几个参数都保存在对象描述文件中， `ridlc`根据接口定义文件（`ridl`文件）在编译的过程中自动设置。如果服务器和代理都在本地，那么进程间调用就只需对象路径和接口名称了。

## 流Streaming
`rpc-frmwrk`可以在服务器和客户端建立字节流通道。流的意义在于可以传输远超过`Request`和`Response`(1MB左右)可以接受的上限的数据。流有如下的特点：
* 流通道是全双工的
* 单个流通道可以传输2^64个字节。
* 流通道保证数据的收发是严格顺序的，先进先出的。
* 流是有流量控制的，用以匹配发送端发送速度和接收端的处理速度。
* 流通道可用于文件传输，或者需要更灵活的传输控制的场景，如非固定格式的数据流媒体流等。
* 流通道由客户端发起并建立，可以由任意一方随时关闭。

在`文件模式`编程时，每一个流通道将体现为分别在服务器端和客户端的一对特殊的可读写文件，数据的收发体现为对文件的读写操作。用户可以通过在客户端建立一个stream文件而建立一个流通道，方式任意，如shell命令`touch stream_1`。单一连接的流通道个数缺省为32个。不过在大量连接的情况下可以进一步限制。

## `FastRpc`和`BuiltinRt App`
* `FastRpc`是通过`Streaming Channel`传输RPC的请求，响应和事件的机制。对应的`ridlc`的选项是`-s`.这个架构的优势是，消息短小，延迟小，吞吐量大，不受DBus的瓶颈限制，而且有session级别的QPS流控。劣势是占用的系统资源较大，需要三倍于普通RPC的可打开文件，并且建立连接的时间长于一般的RPC.   
* `BiuiltinRt App`是由`ridlc`生成的`紧凑模式`的客户端和服务器端程序，因此不需要提前运行`rpcrouter`。对应的`ridlc`的选项是`-b`. 实际上是这类App内部加入了`rpcrouter`的运行库。优点就是可以直接运行，而且延迟小响应快。客户端的程序还可以通过`--nodbus`运行于没有dbus-daemon的系统如`docker`上的. `ridlc`客户端和服务器端程序，还整合了一些`rpcrouter`的命令行选项，可以通过`<appname> -h`查看.   
* 当指定`-bs`时，`ridlc`将生成`builtin-app`并使用`FastRpc`传输RPC消息。`ridlc`生成的`C++`, `Java`, `Python`代码框架都支持这两个选项。`JS`由于架构的完全不同，所以不支持`-b`的选项， 不过`JS`支持`-s`选项，方便连接由`-s`生成的服务器程序。

## 部署
* `rpc-frmwrk`的运行程序可以通过`deb`, `rpm`包或者`tar`包进行安装。
* `rpcfg.py`程序有简易的密钥管理功能，可以生成`openssl`和`gmssl`的自签名密钥供测试和内部使用.
* `rpcfg.py`的部署功能，可以生成`rpc-frmwrk`的安装包，以方便部署到生产系统或者嵌入式系统等没有开发环境的平台上。自动设置的内容包括安装`rpc-frmwrk`的运行库，用包中文件配置`rpc-frmwrk`服务器，部署密钥，配置Web服务器和Kerberos服务器。详情参考`rpcfg.py`的[使用手册](./tools/README_cn.md#rpc-frmwrk配置工具)。有关安装包的命名可以参考这篇[文章](./rpc/gmsslport/README_cn.md)。

## rpcrouter级联功能和路由器路径
当`rpc-frmwrk`的级联(multihop)功能提供了透明访问不同节点上的服务的功能。当rpcrouter以树形级联(multihop)方式部署时，可以使客户端程序通过树根节点（注：可以把一个节点理解成一个主机），访问树上的所有节点，而不用重复建立连接。这时对某个节点的访问，就需要`路由器路径`来标识目的地。级联(Multihop)的配置可以使用`rpcfg.py`配置工具完成。有关级联功能的更多技术信息请参考这篇[wiki](https://github.com/zhiming99/rpc-frmwrk/wiki/Introduction-of-Multihop-support)。

## 安全和认证
* `rpc-frmwrk`通过OpenSSL或GmSSL支持[SSL连接](./rpc/sslport/Readme.md)，或者基于[WebSocket](./rpc/wsport/Readme.md)的SSL连接。
* `rpc-frmwrk`支持[Kerberos 5认证](./rpc/security/README_cn.md#kerberos)。Krb5提供单点登陆支持，也提供AES的加密或者签名功能。就是说数据可以获得SSL之外的二重加密。出于性能方面的考虑，数据签名+SSL是更加合适的组合。
* `rpc-frmwrk`也支持OAuth2的认证，这一认证方式可用于所有客户端，尤其是[JS客户端](./js/README_cn.md)的授权。
* `rpc-frmwrk`也支持SimpAuth的认证，这是rpc-frmwrk内建的认证机制，这一认证方式可用于C++, Python, Java和Javascript客户端，详细介绍见此篇[文章](./rpc/security/README_cn.md)。
* `rpc-frmwrk`的安全和认证功能封装在守护进程中，并通过图形配置工具进行设置。用户代码无需进行修改。

## 负载均衡
`rpc-frmwrk`在Multihop的基础上支持Round-Robin负载均衡。由于`rpc-frmwrk`的对话(Session)是有状态的长链接，负载均衡是以在连接建立时进行的，一旦连接建立起来，就不再进行负载均衡，也就不存在逐个Request负载均衡。这是和RESTful架构的RPC不同之处。关于负载均衡的详细介绍可以参考这篇[文章](https://github.com/zhiming99/rpc-frmwrk/wiki/Introduction-of-Multihop-support#node-redundancyload-balance)。

## `rpcfs`文件系统
`rpcfs`文件系统是一个由Linux FUSE支持的文件系统，是`rpc-frmwrk`提供的有别于传统编程接口的应用接口和管理接口，它主要有以下功能   
* 加载和启停用户的服务器或者代理模块。
* 导出业务模块的运行时状态。
* 增加或者减少发送`Request`的并发量，发送和接收代理的`Request`。
* 增加或者减少`Response`的处理进程，发送和接收服务器的`Response`和`Event`。
* 添加，删除流通道，发送和接收字节流。
* 导出守护进程的运行状态，和参数和计数器统计。
* 通过mount/umount优雅的关闭服务器或者客户端。
* 关于`rpcfs`的内容和结构可以参考这篇[文章](./fuse/README.md)。
* `rpc-frmwrk`将提供支持`rpcfs`编程的框架生成工具。

## I/O子系统
`rpc-frmwrk`的I/O子系统类似于操作系统的I/O系统，有驱动程序和端口对象组成。不管是服务器还是代理程序都需要I/O子系统。I/O子系统的配置放在`driver.json`的文件中，它给出服务器和代理程序需要加载的驱动程序和类库。在系统目录下的`driver.json`给出了守护进程，系统自带的工具，和测试用例所需要加载的驱动程序和类库。I/O子系统的主要特点是可以分层的，就是由多层的端口对象来组成一个管线(Pipeline)，用以处理复杂的I/O需求。另一个特点是它是异步的，每个I/O请求对应一个IoRequestPacket对象，它保存了该I/O请求的所有信息和状态，以保证在I/O就绪时，可以发起新的I/O操作，继续未完成的操作，或者出错时，取消当前的操作。

## 内存管理
`rpc-frmwrk`采用引用计数来管理C++对象的生命周期。所有的对象都继承自基类CObjBase。在此基础上，`rpc-frmwrk`提供了CAutoPtr进一步封装了引用计数的管理。使用CAutoPtr可以有效降低内存泄漏的风险。需要注意的是尽量避免`相互引用`的问题，也就是两个对象分别保有对方的引用计数，或者CAutoPtr。如果不能避免，要在执行析构函数前，一方要主动释放掉自己持有的对方对象的引用计数，或者指向对方的CAutoPtr变量。

## DBus的作用
DBus是一个本地的消息总线，似乎和RPC关系不大。实际上，`rpc-frmwrk`的服务器预想的运行环境下，不仅会接受来自远程互联网的请求，也会接收到本地服务器的请求，以及转发一些请求到其他的服务器进程。虽然这些服务器也可以使用TCP进行传输，但是比起DBus这类轻量级的IPC传输，就显得笨拙低效了。因此DBus就充当了本地间的通信的通道。服务器端，DBus是必须的组件，而客户端则可以运行在没有DBus的环境中。

## rpcfctl工具
`rpcfctl`是rpc-frmwrk内建的命令行工具。它由二十多个子命令组成，可以快捷的访问各种rpc-frmwrk的管理，维护和监控工具。有关它的详细信息可以参考[`rpcfctl`](./monitor/appmon/rpcfctl_cn.md)

## driver.json
[`driver.json`](./ipc/driver.json)文件是I/O子系统的配置文件。`rpc-frmwrk`会在系统目录安装一份缺省的`driver.json`。该文件主要包括四类配置：
* 驱动程序数组(Drivers)：每一个数组元素是一个驱动程序的名称，类型，和支持的端口类。驱动程序可以动态或者静态的创建端口对象，并管理这些对象。
* `端口`数组(Ports)：每一个数组元素是一个端口类的名称，类型。端口对象可以由驱动程序建立，或者由总线类(Bus Port)的端口创建。数组元素中会指定创建该端口对象的是驱动程序还是总线端口。有些端口对象，如RpcTcpBusPort会指定TCP的连接信息还有TCP连接上的服务设置。
* `模块`数组(Modules)：系统的driver.json包含系统程序的启动时需加载的驱动程序，工厂类，或者静态库。系统程序包括`rpcrouter`, `rpcf_logger`, `regfsmnt`。和一些例子程序，比如HelloWorld的程序等。`ridlc`没有用到IoManager，所以也就不需要`driver.json` 
* `匹配`数组(Match)：匹配数组的元素用来告诉IoManager`pdo`类的端口对象建立起来后，它上游的`fdo`和`fido`等端口对象的加载顺序。
  
注意事项：
* `driver.json`除了系统目录下的，也会由`ridlc`为生成的客户端和服务器端程序生成。这个版本的`driver.json`只包含一些该服务器端和客户端相关的配置，所以这个版本可以启动客户端和服务器端的程序，但是不能用来启动`rpc-frmwrk`系统的程序。
* 如果当前目录下，如果没有`driver.json`,那么IoManager会使用系统的`driver.json`。需要注意的是，`rpcrouter`等系统程序应该一直使用系统的`driver.json`。如果启动`rpcrouter`的目录下有同名的`driver.json`，除非有意而为之，会导致`rpcrouter`不能启动。

## 性能
`rpc-frmwrk`在一个i7的4核笔记本上的测试中，1000-5000个连接测试中，2000个连接时达到吞吐量峰值，单个`Request`的平均响应时间在1.1ms左右。大流量并发时服务器的吞吐量大概在每秒2500 Requests. 

## 开发和调试
* `rpc-frmwrk`通过`ridl`接口描述语言定义函数接口，和需要传输的数据结构。并通过`ridlc`生成各种语言的框架代码，配置文件，以及Makefile和Readme文件.
* 同一`ridl`文件生成的不同框架的客户端和服务器可以互操作。有关`ridl`语言的介绍请点击此[链接](./ridl/README_cn.md)。

* `rpc-frmwrk`内建了一套基于C++的API，对于希望进一步了解`rpc-frmwrk`接口工作原理，或者觉得ridlc生成的代码太慢，想榨取更高的性能的同学，可以参考[`test`](./test)目录下的代码。欢迎改进和优化`rpc-frmwrk`的各种建议。
  
* `rpc-frmwrk`的调试版提供了一套基于GDB环境的调试函数可以快速的浏览所有内存对象，是查找各种内存泄漏和运行错误的有力工具。

* `ridlc`是`ridl compiler`的意思。有关`ridlc`的详细信息请参考上面提到的`ridl`的详细介绍一文。

## 意见和建议
对本项目有任何的建议，或者吐槽，请务必不吝赐教。

