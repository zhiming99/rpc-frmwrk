// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -O . oa2check.ridl 
#pragma once
#include <string>
#include "rpc.h"
#include "ifhelper.h"
#include "counters.h"
#include "seribase.h"

#define DECLPTRO( _type, _name ) \
    ObjPtr p##_name;\
    p##_name.NewObj( clsid( _type ) );\
    _type& _name=*(_type*)p##_name;

enum EnumMyClsid
{
    DECL_CLSID( COA2proxy_CliSkel ) = 0x697B13BB,
    DECL_CLSID( COA2proxy_SvrSkel ),
    DECL_CLSID( COA2proxy_CliImpl ),
    DECL_CLSID( COA2proxy_SvrImpl ),
    
    DECL_IID( OAuth2Proxy ),

    DECL_CLSID( timespec ) = 0xF3881ACE,
    DECL_CLSID( USER_INFO ) = 0x07A5D5B5,
    DECL_CLSID( OA2EVENT ) = 0x7D93773C,
};

struct timespec
    : public CStructBase
{
    typedef CStructBase super;
    
    //Message identity
    guint32 m_dwMsgId = clsid( timespec );
    std::string m_strMsgId = "oa2check::timespec";
    // data members
    guint64 tv_sec;
    
    // Constructor
    timespec() : super()
    { SetClassId( ( EnumClsid )m_dwMsgId ); }

    // methods
    gint32 Serialize(
        BufPtr& pBuf_ ) override;
    
    gint32 Deserialize(
        BufPtr& pBuf_ ) override;
    
    guint32 GetMsgId() const override
    { return m_dwMsgId; }
    
    const std::string&
        GetMsgName() const override
    { return m_strMsgId; }
    
    timespec& operator=(
        const timespec& rhs );
};

struct USER_INFO
    : public CStructBase
{
    typedef CStructBase super;
    
    //Message identity
    guint32 m_dwMsgId = clsid( USER_INFO );
    std::string m_strMsgId = "oa2check::USER_INFO";
    // data members
    std::string strUserId;
    std::string strUserName;
    std::string strEmail;
    timespec tsExpireTime;
    
    // Constructor
    USER_INFO() : super()
    { SetClassId( ( EnumClsid )m_dwMsgId ); }

    // methods
    gint32 Serialize(
        BufPtr& pBuf_ ) override;
    
    gint32 Deserialize(
        BufPtr& pBuf_ ) override;
    
    guint32 GetMsgId() const override
    { return m_dwMsgId; }
    
    const std::string&
        GetMsgName() const override
    { return m_strMsgId; }
    
    USER_INFO& operator=(
        const USER_INFO& rhs );
};

struct OA2EVENT
    : public CStructBase
{
    typedef CStructBase super;
    
    //Message identity
    guint32 m_dwMsgId = clsid( OA2EVENT );
    std::string m_strMsgId = "oa2check::OA2EVENT";
    // data members
    std::string strUserId;
    guint32 dwEventId;
    std::string strDesc;
    
    // Constructor
    OA2EVENT() : super()
    { SetClassId( ( EnumClsid )m_dwMsgId ); }

    // methods
    gint32 Serialize(
        BufPtr& pBuf_ ) override;
    
    gint32 Deserialize(
        BufPtr& pBuf_ ) override;
    
    guint32 GetMsgId() const override
    { return m_dwMsgId; }
    
    const std::string&
        GetMsgName() const override
    { return m_strMsgId; }
    
    OA2EVENT& operator=(
        const OA2EVENT& rhs );
};

class IOAuth2Proxy_PImpl
    : public virtual CAggInterfaceProxy
{
    public:
    typedef CAggInterfaceProxy super;
    IOAuth2Proxy_PImpl( const IConfigDb* pCfg ) :
        super( pCfg )
        {}
    gint32 InitUserFuncs();
    
    const EnumClsid GetIid() const override
    { return iid( OAuth2Proxy ); }

    //RPC Async Req Sender
    gint32 DoLogin( 
        IConfigDb* context, 
        const std::string& strToken, 
        USER_INFO& ui );

    gint32 DoLoginDummy( BufPtr& pBuf_ )
    { return STATUS_SUCCESS; }
    
    //Async callback wrapper
    gint32 DoLoginCbWrapper( 
        IEventSink* pCallback, 
        IEventSink* pIoReq,
        IConfigDb* pReqCtx );
    
    //RPC Async Req Callback
    //TODO: implement me by adding
    //response processing code
    virtual gint32 DoLoginCallback(
        IConfigDb* context, 
        gint32 iRet,USER_INFO& ui ) = 0;
    
    //RPC Async Req Sender
    gint32 GetUserInfo( 
        IConfigDb* context, 
        const std::string& strToken, 
        USER_INFO& ui );

    gint32 GetUserInfoDummy( BufPtr& pBuf_ )
    { return STATUS_SUCCESS; }
    
    //Async callback wrapper
    gint32 GetUserInfoCbWrapper( 
        IEventSink* pCallback, 
        IEventSink* pIoReq,
        IConfigDb* pReqCtx );
    
    //RPC Async Req Callback
    //TODO: implement me by adding
    //response processing code
    virtual gint32 GetUserInfoCallback(
        IConfigDb* context, 
        gint32 iRet,USER_INFO& ui ) = 0;
    
    //RPC Async Req Sender
    gint32 RevokeUser( 
        IConfigDb* context, 
        const std::string& strToken );

    gint32 RevokeUserDummy( BufPtr& pBuf_ )
    { return STATUS_SUCCESS; }
    
    //Async callback wrapper
    gint32 RevokeUserCbWrapper( 
        IEventSink* pCallback, 
        IEventSink* pIoReq,
        IConfigDb* pReqCtx );
    
    //RPC Async Req Callback
    //TODO: implement me by adding
    //response processing code
    virtual gint32 RevokeUserCallback(
        IConfigDb* context, 
        gint32 iRet ) = 0;
    
    //RPC event handler 'OnOA2Event'
    //TODO: implement me
    virtual gint32 OnOA2Event(
        OA2EVENT& oEvent ) = 0;
    
    //RPC event handler wrapper
    gint32 OnOA2EventWrapper(
        IEventSink* pCallback, BufPtr& pBuf_ );
    
};

DECLARE_AGGREGATED_PROXY(
    COA2proxy_CliSkel,
    CStatCountersProxy,
    IOAuth2Proxy_PImpl );

