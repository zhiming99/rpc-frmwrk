// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -O . ../oaproxy.ridl 
#pragma once
#include <string>
#include "rpc.h"
#include "ifhelper.h"
#include "counters.h"
#include "seribase.h"

#define DECLPTRO( _type, _name ) \
    ObjPtr p##_name;\
    p##_name.NewObj( clsid( _type ) );\
    _type& _name=*(_type*)p##_name;

enum EnumMyClsid
{
    DECL_CLSID( COA2proxy_CliSkel ) = 0x697B13BB,
    DECL_CLSID( COA2proxy_SvrSkel ),
    DECL_CLSID( COA2proxy_CliImpl ),
    DECL_CLSID( COA2proxy_SvrImpl ),
    
    DECL_IID( OAuth2Proxy ),

    DECL_CLSID( USER_INFO ) = 0x07A5D5B5,
};

struct USER_INFO
    : public CStructBase
{
    typedef CStructBase super;
    
    //Message identity
    guint32 m_dwMsgId = clsid( USER_INFO );
    std::string m_strMsgId = "oa2check::USER_INFO";
    // data members
    std::string strUserId;
    std::string strUserName;
    std::string strEmail;
    
    // Constructor
    USER_INFO() : super()
    { SetClassId( ( EnumClsid )m_dwMsgId ); }

    // methods
    gint32 Serialize(
        BufPtr& pBuf_ ) override;
    
    gint32 Deserialize(
        BufPtr& pBuf_ ) override;
    
    guint32 GetMsgId() const override
    { return m_dwMsgId; }
    
    const std::string&
        GetMsgName() const override
    { return m_strMsgId; }
    
    USER_INFO& operator=(
        const USER_INFO& rhs );
};

class IOAuth2Proxy_PImpl
    : public virtual CAggInterfaceProxy
{
    public:
    typedef CAggInterfaceProxy super;
    IOAuth2Proxy_PImpl( const IConfigDb* pCfg ) :
        super( pCfg )
        {}
    gint32 InitUserFuncs();
    
    const EnumClsid GetIid() const override
    { return iid( OAuth2Proxy ); }

    //RPC Async Req Sender
    gint32 IsTokenValid( 
        IConfigDb* context, 
        const std::string& strToken, 
        bool& bValid );

    gint32 IsTokenValidDummy( BufPtr& pBuf_ )
    { return STATUS_SUCCESS; }
    
    //Async callback wrapper
    gint32 IsTokenValidCbWrapper( 
        IEventSink* pCallback, 
        IEventSink* pIoReq,
        IConfigDb* pReqCtx );
    
    //RPC Async Req Callback
    //TODO: implement me by adding
    //response processing code
    virtual gint32 IsTokenValidCallback(
        IConfigDb* context, 
        gint32 iRet,bool bValid ) = 0;
    
    //RPC Async Req Sender
    gint32 GetUserInfo( 
        IConfigDb* context, 
        const std::string& strToken, 
        USER_INFO& ui );

    gint32 GetUserInfoDummy( BufPtr& pBuf_ )
    { return STATUS_SUCCESS; }
    
    //Async callback wrapper
    gint32 GetUserInfoCbWrapper( 
        IEventSink* pCallback, 
        IEventSink* pIoReq,
        IConfigDb* pReqCtx );
    
    //RPC Async Req Callback
    //TODO: implement me by adding
    //response processing code
    virtual gint32 GetUserInfoCallback(
        IConfigDb* context, 
        gint32 iRet,USER_INFO& ui ) = 0;
    
    //RPC Async Req Sender
    gint32 RevokeUser( 
        IConfigDb* context, 
        const std::string& strToken );

    gint32 RevokeUserDummy( BufPtr& pBuf_ )
    { return STATUS_SUCCESS; }
    
    //Async callback wrapper
    gint32 RevokeUserCbWrapper( 
        IEventSink* pCallback, 
        IEventSink* pIoReq,
        IConfigDb* pReqCtx );
    
    //RPC Async Req Callback
    //TODO: implement me by adding
    //response processing code
    virtual gint32 RevokeUserCallback(
        IConfigDb* context, 
        gint32 iRet ) = 0;
    
};

DECLARE_AGGREGATED_PROXY(
    COA2proxy_CliSkel,
    CStatCountersProxy,
    IOAuth2Proxy_PImpl );

