// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -O . ../oaproxy.ridl 
// Implement the following methods
// to get the RPC proxy/server work
#include "rpc.h"
using namespace rpcf;
#include "oa2check.h"
#include "OA2proxycli.h"

// OAuth2Proxy Proxy
/* Async Req Complete Handler*/
gint32 COA2proxy_CliImpl::IsTokenValidCallback(
    IConfigDb* context, gint32 iRet,
    bool bValid /*[ In ]*/ )
{
    // TODO: Process the server response here
    // return code ignored
    return 0;
}

/* Async Req Complete Handler*/
gint32 COA2proxy_CliImpl::GetUserInfoCallback(
    IConfigDb* context, gint32 iRet,
    USER_INFO& ui /*[ In ]*/ )
{
    // TODO: Process the server response here
    // return code ignored
    return 0;
}

/* Async Req Complete Handler*/
gint32 COA2proxy_CliImpl::RevokeUserCallback(
    IConfigDb* context, gint32 iRet )
{
    // TODO: Process the server response here
    // return code ignored
    return 0;
}

gint32 COA2proxy_CliImpl::AddSession(
    guint32 dwPortId, 
    const std::string& strSess )
{
    m_mapPortId2Sess[ dwPortId ] = strSess;
    m_mapSess2PortId[ strSess ] = dwPortId;
    return STATUS_SUCCESS;
}

gint32 COA2proxy_CliImpl::RemoveSession(
    guint32 dwPortId )
{
    // the caller makes sure the gss lock is
    // acquired.
    auto itr = m_mapSessions.find( dwPortId);
    if( itr != m_mapSessions.end() )
        m_mapSessions.erase( itr );

    auto itr1 =
        m_mapPortId2Sess.find( dwPortId );
    if( itr1 != m_mapPortId2Sess.end() ) 
    {
        std::string strSess = itr1->second;
        m_mapPortId2Sess.erase( itr1 );
        m_mapSess2PortId.erase( strSess );
    }

    return STATUS_SUCCESS;
}

gint32 COA2proxy_CliImpl::RemoveSession(
    const std::string& strSess )
{
    // the caller makes sure the gss lock is
    // acquired.
    CStdRMutex oGssLock( this->GetLock() );
    auto itr2 =
        m_mapSess2PortId.find( strSess );
    if( itr2 == m_mapSess2PortId.end() )
        return -ENOENT;

    guint32 dwPortId = itr2->second;
    return RemoveSession( dwPortId );
}

gint32 COA2proxy_CliImpl::IsSessExpired(
    IEventSink* pCallback,
    const std::string& strSess )
{
    gint32 ret = 0;
    do{
    }while( 0 );

    return ret;
}

extern gint32 gen_sess_hash(
    BufPtr& pBuf,
    std::string& strSess );

gint32 COA2proxy_CliImpl::GenSessHash(
    stdstr strToken,
    guint32 dwPortId,
    std::string& strSess )
{
    if( dwPortId == 0 )
        return -EINVAL;

    gint32 ret = 0;
    do{
        BufPtr pBuf( true );
        ret = pBuf->Append( strToken.c_str(),
            strToken.size() );
        if( ERROR( ret ) )
            break;

        CRpcRouterBridge* pRouter =
            static_cast< CRpcRouterBridge* >
                ( GetRouter() );
        if( unlikely( pRouter == nullptr ) )
        {
            ret = -EFAULT;
            break;
        }

        InterfPtr pIf;
        ret = pRouter->GetBridge( dwPortId, pIf );
        if( ERROR( ret ) )
            break;

        CCfgOpenerObj oIfCfg( ( CObjBase* )pIf );
        IConfigDb* pConn;
        ret = oIfCfg.GetPointer(
            propConnParams, pConn );
        if( ERROR( ret ) )
            break;

        ret = AppendConnParams( pConn, pBuf );
        if( ERROR( ret ) )
            break;

        guint64 qwSalt = pIf->GetObjId();
        qwSalt = htonll( qwSalt );

        pBuf->Append( ( char* )&qwSalt,
            sizeof( qwSalt ) );

        stdstr strRet;
        ret = gen_sess_hash( pBuf, strRet );
        if( ERROR( ret ) )
            break;

        strSess = "AUoa";
        strSess += strRet;

        DebugPrint( 0, "Sess hash is %s",
            strSess.c_str() );

    }while( 0 );

    return ret;
}
