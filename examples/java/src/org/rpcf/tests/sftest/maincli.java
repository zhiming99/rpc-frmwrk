// GENERATED BY RIDLC. MAKE SURE TO BACKUP BEFORE RE-COMPILING.
package org.rpcf.tests.sftest;

import org.rpcf.rpcbase.JRetVal;
import org.rpcf.rpcbase.JavaRpcContext;
import org.rpcf.rpcbase.RC;
import org.rpcf.rpcbase.rpcbase;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.concurrent.TimeUnit;
public class maincli
{
    public static JavaRpcContext m_oCtx;
    public static String getDescPath( String strName )
    {
        String strDescPath =
            maincli.class.getProtectionDomain().getCodeSource().getLocation().getPath();
        String strDescPath2 = strDescPath + "/org/rpcf/tests/sftest/" + strName;
        java.io.File oFile = new java.io.File( strDescPath2 );
        if( oFile.isFile() )
            return strDescPath2;
        strDescPath += "/" + strName;
        oFile = new java.io.File( strDescPath );
        if( oFile.isFile() )
            return strDescPath;
        return "";
    }
    @SuppressWarnings("empty-statement")
    public static byte[] getMD5(String strPath)
    {
        byte[] digest;
        try{
            byte[] buf = new byte[1024];
            MessageDigest md = MessageDigest.getInstance("MD5");
            try (InputStream is = Files.newInputStream(Paths.get(strPath));
            DigestInputStream dis = new DigestInputStream(is, md)) {
                while(dis.read(buf,0,buf.length) != -1);
                digest = md.digest();
            }
        }catch(IOException | NoSuchAlgorithmException e){
            return null;
        }
        return digest;
    }
    public static void main( String[] args )
    {
        m_oCtx = JavaRpcContext.createProxy(); 
        if( m_oCtx == null )
            System.exit( RC.EFAULT );

        if(args.length != 1) {
            System.out.println("usage: java maincli <filename>");
            System.exit(RC.EINVAL);
        }
        File testFile = new File(args[0]);
        if(!testFile.exists() ||
                !testFile.isFile() ||
                testFile.length() == 0)
        {
            System.out.printf("%s is not a valid file\n", args[0]);
            System.exit(RC.EINVAL);
        }

        String strDescPath =
            getDescPath( "sftestdesc.json" );
        if( strDescPath.isEmpty() )
            System.exit( RC.ENOENT );

        // create the service object
        FileTransfercli oSvcCli = new FileTransfercli(
            m_oCtx.getIoMgr(), 
            strDescPath,
            "FileTransfer" );

        // check if there are errors
        if( RC.ERROR( oSvcCli.getError() ) )
            System.exit( -oSvcCli.getError() );
        
        // start the proxy
        int ret = oSvcCli.start();
        if( RC.ERROR( ret ) )
            System.exit( -ret );
        
        do{
            // test remote server is not online
            while( oSvcCli.getState() == RC.stateRecovery )
            try{
                TimeUnit.SECONDS.sleep(1);
            }
            catch( InterruptedException ignored){}

            if( oSvcCli.getState() != RC.stateConnected )
            { ret = RC.ERROR_STATE;break;}

            long hChannel;
            rpcbase.JavaOutputMsg("Opening stream channel...");
            JRetVal jret = oSvcCli.startStream(null);
            if(jret.ERROR())
            {
                rpcbase.JavaOutputMsg(
                        "Failed to open streaming channel");
                ret = jret.getError();
                break;
            }
            hChannel = jret.getAtLong(0);
            String strFile = args[0];

            // wait for peer ready
            jret = oSvcCli.readStream(hChannel);
            if(jret.ERROR())
            {
                ret = jret.getError();
                break;
            }
            byte[] byToken = (byte[]) jret.getAt(0);
            if(!new String(byToken, StandardCharsets.UTF_8).equals("rdy"))
            {
                ret = RC.ERROR_FAIL;
                break;
            }

            rpcbase.JavaOutputMsg(
                    "Streaming channel opened successfully");

            rpcbase.JavaOutputMsg(
                    "uploading file...");

            // upload the specified file
            ret = oSvcCli.uploadFile( hChannel, strFile );
            if( RC.ERROR(ret) )
                break;
            if( RC.isPending(ret) )
                oSvcCli.m_oTransCtx.waitForComplete();

            ret = oSvcCli.m_oTransCtx.getError(hChannel);
            if(RC.ERROR(ret))
                break;

            // receive a receiving complete token from server
            jret = oSvcCli.readStream(hChannel);
            if(jret.ERROR())
            {
                ret = jret.getError();
                break;
            }
            byToken = (byte[]) jret.getAt(0);
            if(!new String(byToken, StandardCharsets.UTF_8).equals("over"))
            {
                ret = RC.ERROR_FAIL;
                break;
            }
            rpcbase.JavaOutputMsg("uploadFile completed");
            oSvcCli.m_oTransCtx.removeContext(hChannel);

            // download the file we have uploaded.
            String strBaseName =
                    TransFileContext.getFileName(strFile);

            rpcbase.JavaOutputMsg(
                    "Getting file info from server...");

            // get the remote file info before we can download
            jret = oSvcCli.GetFileInfo(strBaseName);
            if(jret.ERROR())
            {
                ret = jret.getError();
                break;
            }
            FileInfo fi = (FileInfo)jret.getAt(0);

            rpcbase.JavaOutputMsg(
                    "Downloading file...");
            ret = oSvcCli.downloadFile(
                    hChannel,strBaseName,0, fi.qwSize);
            if(RC.ERROR(ret)) {
                rpcbase.JavaOutputMsg("downloadFile failed");
                break;
            }
            if(RC.isPending(ret))
                oSvcCli.m_oTransCtx.waitForComplete();
            ret =oSvcCli.m_oTransCtx.getError(hChannel);
            oSvcCli.m_oTransCtx.removeContext(hChannel);

            if(RC.ERROR(ret)) {
                // download failed
                break;
            }
            rpcbase.JavaOutputMsg("downloadFile completed");
            // download succeeded. Check if the transfer is OK.
            byte[] origMd5 = getMD5(strFile);
            byte[] downMd5 = getMD5("./" + strBaseName + ".1");

            if(origMd5 == null || downMd5 == null )
            {
                ret = RC.ERROR_FAIL;
                break;
            }

            if( !Arrays.equals(origMd5, downMd5) ) {
                rpcbase.JavaOutputMsg(
                        "the file contents are not the same");
                ret = RC.ERROR_FAIL;
                break;
            }
            rpcbase.JavaOutputMsg("MD5 check passed, sftest completed");
            oSvcCli.closeStream(hChannel);

            jret = oSvcCli.RemoveFile(strBaseName);
            if(jret.ERROR())
                rpcbase.JavaOutputMsg(
                        "Removing remote file failed " + strBaseName);
            else
                rpcbase.JavaOutputMsg("Removed the remote file");

            File downFile = new File(
                    "./" + strBaseName + ".1");
            if( downFile.delete() )
                rpcbase.JavaOutputMsg("Removed the local file");

        }while( false );

        oSvcCli.stop();
        m_oCtx.stop();
        if(RC.ERROR(ret))
            rpcbase.JavaOutputMsg("sftest failed");
        System.exit( -ret );
    }
}
