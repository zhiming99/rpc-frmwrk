// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -O . ../../sftest.ridl 
#include "rpc.h"
#include "proxy.h"
using namespace rpcf;
#include "FileTransfercli.h"

ObjPtr g_pIoMgr;

FactoryPtr InitClassFactory()
{
    BEGIN_FACTORY_MAPS;

    INIT_MAP_ENTRYCFG( CFileTransfer_CliImpl );
    
    INIT_MAP_ENTRY( FileInfo );
    
    END_FACTORY_MAPS;
}

extern "C"
gint32 DllLoadFactory( FactoryPtr& pFactory )
{
    pFactory = InitClassFactory();
    if( pFactory.IsEmpty() )
        return -EFAULT;
    return STATUS_SUCCESS;
}

gint32 InitContext()
{
    gint32 ret = CoInitialize( 0 );
    if( ERROR( ret ) )
        return ret;
    do{
        // load class factory for 'sftest'
        FactoryPtr p = InitClassFactory();
        ret = CoAddClassFactory( p );
        if( ERROR( ret ) )
            break;
        
        CParamList oParams;
        oParams.Push( "sftestcli" );

        // adjust the thread number if necessary
        oParams[ propMaxIrpThrd ] = 0;
        oParams[ propMaxTaskThrd ] = 1;
        
        ret = g_pIoMgr.NewObj(
            clsid( CIoManager ), 
            oParams.GetCfg() );
        if( ERROR( ret ) )
            break;

        CIoManager* pSvc = g_pIoMgr;
        ret = pSvc->Start();
        
    }while( 0 );

    return ret;
}

gint32 DestroyContext()
{
    IService* pSvc = g_pIoMgr;
    if( pSvc != nullptr )
    {
        pSvc->Stop();
        g_pIoMgr.Clear();
    }

    CoUninitialize();
    DebugPrintEx( logErr, 0,
        "#Leaked objects is %d",
        CObjBase::GetActCount() );
    return STATUS_SUCCESS;
}

gint32 maincli( CFileTransfer_CliImpl* pIf, int argc, char** argv );

int main( int argc, char** argv )
{
    gint32 ret = 0;
    do{
        std::string strDesc = "./sftestdesc.json";
        ret = InitContext();
        if( ERROR( ret ) )
            break;
        
        CRpcServices* pSvc = nullptr;
        InterfPtr pIf;
        do{
            CParamList oParams;
            oParams[ propIoMgr ] = g_pIoMgr;
            
            ret = CRpcServices::LoadObjDesc(
                strDesc, "FileTransfer",
                false, oParams.GetCfg() );
            if( ERROR( ret ) )
                break;
            ret = pIf.NewObj(
                clsid( CFileTransfer_CliImpl ),
                oParams.GetCfg() );
            if( ERROR( ret ) )
                break;
            pSvc = pIf;
            ret = pSvc->Start();
            if( ERROR( ret ) )
                break;
            while( pSvc->GetState()== stateRecovery )
                sleep( 1 );
            
            if( pSvc->GetState() != stateConnected )
            {
                ret = ERROR_STATE;
                break;
            }
        }while( 0 );
        
        if( SUCCEEDED( ret ) )
            ret = maincli( pIf, argc, argv );
            
        // Stopping the object
        if( !pIf.IsEmpty() )
            pIf->Stop();
    }while( 0 );

    DestroyContext();
    return ret;
}

//-----Your code begins here---

gint32 GetMD5( const stdstr& strFile, stdstr& digest )
{
    gint32 ret = 0;
    stdstr strCmd;
    const char* args[3] = {
        "/usr/bin/md5sum", strFile.c_str(), nullptr };
    stdstr strOutput = "./output_.md5";
    char* env[ 1 ] = { nullptr };
    ret = Execve( "/usr/bin/md5sum",
        const_cast< char* const*>( args ),
        env, strOutput.c_str() );
    if( ret != 0 )
        return ret;
    FILE* fp = fopen( strOutput.c_str(), "rb" );
    if( fp == nullptr )
        return -errno;
    BufPtr pBuf( true );
    pBuf->Resize( 64 );
    fread( pBuf->ptr(), 32, 1, fp );
    pBuf->ptr()[ 32 ] = 0;
    digest = pBuf->ptr();
    unlink( strOutput.c_str() );
    return 0;
}

void Usage( char* cmd )
{
    printf( "usage: %s <filename>\n", cmd );
    return;
}

gint32 maincli(
    CFileTransfer_CliImpl* pIf,
    int argc, char** argv )
{
    gint32 ret = 0;
    do{
        if( argc != 2 )
        {
            Usage( argv[ 0 ] );
            ret = -EINVAL;
            break;
        }

        stdstr strFile = argv[ 1 ];
        if( !IsFileExist( strFile ) ||
            GetFileSize( strFile ) == 0 )
        {
            printf( "Error not a valid file\n" );
            Usage( argv[ 0 ] );
            ret = -EINVAL;
            break;
        }

        OutputMsg( 0, "Open stream channel..." );
        HANDLE hChannel = INVALID_HANDLE;
        ret = pIf->StartStream(
            hChannel, nullptr, nullptr );
        if( ERROR( ret ) )
        {
            OutputMsg( ret, "Error open stream " );
            break;
        }

        CStreamProxyAsync* pStm = ObjPtr( pIf );
        BufPtr pBuf;
        ret = pStm->ReadStream( hChannel, pBuf );
        if( ERROR( ret ) )
            break;

        if( strncmp( "rdy", pBuf->ptr(), 3 ) != 0 )
        {
            ret = ERROR_FAIL;
            break;
        }

        OutputMsg( 0,
            "Streaming channel open successfully" );
        OutputMsg( 0, "uploading file..." );

        ret = pIf->UploadFile( hChannel, strFile );
        if( ret == STATUS_PENDING )
        {
            pIf->m_oTransCtx.WaitForComplete();
            ret = pIf->m_oTransCtx.GetError( hChannel );
        }
        if( ERROR( ret ) )
            break;
        pBuf->Resize(0);

        ret = pStm->ReadStream( hChannel, pBuf ); 
        if( ERROR( ret ) )
            break;

        if( strncmp( "over", pBuf->ptr(), 4 ) != 0 )
        {
            ret = ERROR_FAIL;
            break;
        }
        OutputMsg( 0, "UploadFile Completed" );
        pIf->m_oTransCtx.RemoveContext( hChannel );

        BufPtr pBuf2( true );
        *pBuf2 = strFile;
        stdstr strBaseName = basename( pBuf2->ptr() );
        OutputMsg( ret,
            "Getting info of file '%s' from server",
            strBaseName.c_str() );

        FileInfo fi;
        ret = pIf->GetFileInfo( strBaseName, fi );
        if( ERROR( ret ) )
            break;
         
        OutputMsg( 0,
            "Downloading file %s ...",
            strBaseName.c_str() );
        ret = pIf->DownloadFile(
            hChannel, strBaseName, 0, fi.qwSize );
        if( ERROR( ret ) )
            break;
        if( ret == STATUS_PENDING )
        {
            pIf->m_oTransCtx.WaitForComplete();
            ret = pIf->m_oTransCtx.GetError( hChannel );
        }
        if( ERROR( ret ) )
            break;

        stdstr strDownFile = "./";
        strDownFile += strBaseName + ".1";
        OutputMsg( 0, "DownloadFile completed" );
        stdstr origMD5;
        GetMD5( strFile, origMD5 );
        OutputMsg( 0, "MD5 of original file: %s",
            origMD5.c_str() );
        stdstr downMD5;
        GetMD5( strDownFile, downMD5 );
        OutputMsg( 0, "MD5 of downloaded file: %s",
            downMD5.c_str() );
        if( origMD5 != downMD5 )
        {
            ret = ERROR_FAIL;
            OutputMsg( ret, "md5 check failed" );
            break;
        }
        OutputMsg( 0, "md5 check passed" );
        ret = pIf->RemoveFile( strBaseName );
        OutputMsg( ret, "Removed remote file" );
        unlink( strDownFile.c_str() );
        OutputMsg( ret, "Removed local file" );

    }while( 0 );

    return ret;
}

