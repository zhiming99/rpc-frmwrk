// Generated by ridlc
// ridlc -s -O . ../../stmtest.ridl 
#include "rpc.h"
#include "proxy.h"
using namespace rpcf;
#include "stmport.h"
#include "fastrpc.h"
#include "StreamTestcli.h"

ObjPtr g_pIoMgr;


FactoryPtr InitClassFactory()
{
    BEGIN_FACTORY_MAPS;

    INIT_MAP_ENTRYCFG( CStreamTest_CliImpl );
    INIT_MAP_ENTRYCFG( CStreamTest_CliSkel );
    INIT_MAP_ENTRYCFG( CStreamTest_ChannelCli );
    
    END_FACTORY_MAPS;
}

extern "C"
gint32 DllLoadFactory( FactoryPtr& pFactory )
{
    pFactory = InitClassFactory();
    if( pFactory.IsEmpty() )
        return -EFAULT;
    return STATUS_SUCCESS;
}

gint32 InitContext()
{
    gint32 ret = CoInitialize( 0 );
    if( ERROR( ret ) )
        return ret;
    do{
        // load class factory for 'stmtest'
        FactoryPtr p = InitClassFactory();
        ret = CoAddClassFactory( p );
        if( ERROR( ret ) )
            break;
        
        CParamList oParams;
        oParams.Push( "stmtestcli" );

        // adjust the thread number if necessary
        oParams[ propMaxIrpThrd ] = 0;
        oParams[ propMaxTaskThrd ] = 1;
        
        ret = g_pIoMgr.NewObj(
            clsid( CIoManager ), 
            oParams.GetCfg() );
        if( ERROR( ret ) )
            break;
        
        IService* pSvc = g_pIoMgr;
        ret = pSvc->Start();
        
    }while( 0 );

    if( ERROR( ret ) )
    {
        g_pIoMgr.Clear();
        CoUninitialize();
    }
    return ret;
}

gint32 DestroyContext()
{
    IService* pSvc = g_pIoMgr;
    if( pSvc != nullptr )
    {
        pSvc->Stop();
        g_pIoMgr.Clear();
    }

    CoUninitialize();
    DebugPrintEx( logErr, 0,
        "#Leaked objects is %d",
        CObjBase::GetActCount() );
    return STATUS_SUCCESS;
}

gint32 maincli(
    CStreamTest_CliImpl* pIf,
    int argc, char** argv );

int main( int argc, char** argv)
{
    gint32 ret = 0;
    do{
        ret = InitContext();
        if( ERROR( ret ) )
            break;
        
        stdstr strDesc = "./stmtestdesc.json";
        CStreamTest_CliImpl* pSvc = nullptr;
        InterfPtr pIf;
        do{
            CParamList oParams;
            oParams[ propIoMgr ] = g_pIoMgr;
            
            ret = CRpcServices::LoadObjDesc(
                strDesc, "StreamTest",
                false, oParams.GetCfg() );
            if( ERROR( ret ) )
                break;
            ret = pIf.NewObj(
                clsid( CStreamTest_CliImpl ),
                oParams.GetCfg() );
            if( ERROR( ret ) )
                break;
            pSvc = pIf;
            ret = pSvc->Start();
            if( ERROR( ret ) )
                break;
            while( pSvc->GetState()== stateRecovery )
                sleep( 1 );
            
            if( pSvc->GetState() != stateConnected )
            {
                ret = ERROR_STATE;
                break;
            }

            maincli( pSvc, argc, argv );
            
        }while( 0 );
        
        // Stopping the object
        if( pSvc != nullptr )
            ret = pSvc->Stop();
    }while( 0 );

    DestroyContext();
    return ret;
}

//-----Your code begins here---
gint32 maincli(
    CStreamTest_CliImpl* pIf,
    int argc, char** argv )
{
    gint32 ret = 0;
    do{
        stdstr i0r;
        ret = pIf->Echo( "Hello, stmtest!", i0r );
        if( ERROR( ret ) )
            break;
        OutputMsg( ret,
            "Echo completed with response %s",
            i0r.c_str() );
        HANDLE hChannel = INVALID_HANDLE;
        ret = pIf->StartStream(
            hChannel, nullptr, nullptr );
        if( ERROR( ret ) )
        {
            OutputMsg( ret, "Error open stream " );
            break;
        }

        for( gint32 i = 0; i < 100; i++ )
        {
            stdstr strMsg = "a message to server ";
            strMsg += std::to_string( i );
            BufPtr pBuf( true );
            *pBuf = strMsg;
            ret = pIf->WriteStream( hChannel, pBuf );
            if( ERROR( ret ) )
                break;
            pBuf.Clear();
            ret = pIf->ReadStream( hChannel, pBuf );
            if( ERROR( ret ) )
                break;
            stdstr strBuf = BUF2STR( pBuf );
            OutputMsg( ret,
                "Server says (sync): %s",
                strBuf.c_str() );
            double dbval = i + .1;
            strMsg = "a message to server " +
                std::to_string( dbval );
            pBuf.NewObj();
            *pBuf = strMsg;
            ret = pIf->WriteStreamAsync(
                hChannel, pBuf,
                ( IConfigDb* )nullptr );
            if( ERROR( ret ) )
                break;

            if( ret == STATUS_PENDING )
            {
                pIf->WaitForComplete();
                ret = pIf->GetError();
                if( ERROR( ret ) )
                    break;
            }
            pBuf.Clear();
            ret = pIf->ReadStreamAsync(
                hChannel, pBuf, 
                ( IConfigDb* )nullptr );
            if( ERROR( ret ) )
                break;

            if( ret == STATUS_PENDING )
            {
                pIf->WaitForComplete();
                ret = pIf->GetError();
                if( ERROR( ret ) )
                    break;
                // the response is handled by
                // callback
                continue;
            }
            // immediate return
            strBuf = BUF2STR( pBuf );
            OutputMsg( ret,
                "Server says(async): %s",
                strBuf.c_str() );
        }

    }while( 0 );

    return ret;
}

