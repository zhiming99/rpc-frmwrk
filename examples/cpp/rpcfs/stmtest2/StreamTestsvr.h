// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -s -O . ../../../stmtest.ridl 
#pragma once
#include "stmtest.h"
#include "commdefs.h"
#include "IStreamTestsvr.h"

#define Clsid_CStreamTest_SvrSkel_Base Clsid_Invalid

DECLARE_AGGREGATED_SKEL_SERVER(
    CStreamTest_SvrSkel_Base,
    CStatCountersServerSkel,
    IIStreamTest_SImpl );

class CStreamTest_SvrSkel :
    public CStreamTest_SvrSkel_Base
{
    public:
    typedef CStreamTest_SvrSkel_Base super;
    CStreamTest_SvrSkel( const IConfigDb* pCfg ):
        super::virtbase( pCfg ), super( pCfg )
    { SetClassId( clsid( CStreamTest_SvrSkel ) ); }

    gint32 InvokeUserMethod(
        IConfigDb* pParams,
        IEventSink* pCallback ) override
    {
        CRpcServices* pSvc = nullptr;
        if( !IsRfcEnabled() )
        {
            if( m_pQpsTask.IsEmpty() )
                pSvc = this->GetStreamIf();
            else
                pSvc = this;
            gint32 ret = pSvc->AllocReqToken();
            if( ERROR( ret ) )
                return ret;
        }
        return super::InvokeUserMethod(
            pParams, pCallback );
    }
};

struct TransferContext
{
    gint32 m_iCounter = 0;
    gint32 m_iError = 0;

    inline void IncCounter()
    { m_iCounter++; }
    inline gint32 GetCounter()
    { return m_iCounter; }

    inline void SetError( gint32 iError )
    { m_iError = iError; }

    inline gint32 GetError()
    { return m_iError; }
};
#define Clsid_CStreamTest_SvrBase    Clsid_Invalid

DECLARE_AGGREGATED_SERVER(
    CStreamTest_SvrBase,
    CStatCounters_SvrBase,
    CStreamServerAsync,
    IIStreamTest_SvrApi,
    CFastRpcServerBase );

class CStreamTest_SvrImpl
    : public CStreamTest_SvrBase
{
    public:
    typedef CStreamTest_SvrBase super;
    CStreamTest_SvrImpl( const IConfigDb* pCfg ) :
        super::virtbase( pCfg ), super( pCfg )
    { SetClassId( clsid(CStreamTest_SvrImpl ) ); }

    /* The following 3 methods are important for */
    /* streaming transfer. rewrite them if necessary */
    gint32 OnStreamReady( HANDLE hChannel ) override;
    
    gint32 OnStmClosing( HANDLE hChannel ) override;
    
    gint32 AcceptNewStream(
        IEventSink* pCb, IConfigDb* pDataDesc ) override
    { return STATUS_SUCCESS; }
    
    gint32 OnPostStart(
        IEventSink* pCallback ) override
    {
        TaskletPtr pTask = GetUpdateTokenTask();
        StartQpsTask( pTask );
        if( !pTask.IsEmpty() )
            AllocReqToken();
        return super::OnPostStart( pCallback );
    }

    gint32 OnPreStop(
        IEventSink* pCallback ) override
    {
        StopQpsTask();
        return super::OnPreStop( pCallback );
    }
    
    virtual gint32 OnReadStreamComplete(
        HANDLE hChannel, gint32 iRet,
        BufPtr& pBuf, IConfigDb* pCtx ) override;

    virtual gint32 OnWriteStreamComplete(
        HANDLE hChannel, gint32 iRet,
        BufPtr& pBuf, IConfigDb* pCtx ) override;

    // IStreamTest
    virtual gint32 Echo(
        const std::string& i0 /*[ In ]*/,
        std::string& i0r /*[ Out ]*/ );
    
    gint32 ReadAndReply( HANDLE hChannel );
    gint32 WriteAndReceive( HANDLE hChannel );
    gint32 CreateStmSkel(
        HANDLE, guint32, InterfPtr& ) override;
    
    gint32 OnPreStart(
        IEventSink* pCallback ) override;
};

class CStreamTest_ChannelSvr
    : public CRpcStreamChannelSvr
{
    public:
    typedef CRpcStreamChannelSvr super;
    CStreamTest_ChannelSvr(
        const IConfigDb* pCfg ) :
        super::virtbase( pCfg ), super( pCfg )
    { SetClassId( clsid(
        CStreamTest_ChannelSvr ) ); }
};

