<!--
 GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
 Copyright (C) 2024  zhiming <woodhead99@gmail.com>
 This program can be distributed under the terms of the GNU GPLv3.

* command line: /usr/local/bin/ridlc -JO. --odesc_url=http://example.com/rpcf ../../sftest.ridl 
* npm dependency: browserify buffer exports long lz4 process put safe-buffer stream xxhash webpack
-->
<!DOCTYPE html>
<html><head><meta charset="utf-8" /></head></html>
<body>
<p id="log">Sample HTML<br /></p>

<label for="sample file">Select a file</label>
<input id="FileToUpload" name="FileToUpload" type="file" value="Upload" >

<script>

var oStmCtx = new Object();

function LoadFile()
{
    let file = this.files[0];

    const reader = new FileReader();

    reader.onabort     = function(e) { /* @TODO */ }
    reader.onerror     = function(e) { /* @TODO */ }
    reader.onloadstart = function(e) { /* @TODO */ }
    reader.onprogress  = function(e) { /* @TODO */ }
    reader.onload = function(e) // only triggered if successful
    {
        oStmCtx.rawData = e.target.result
        if( !oProxy )
        {
            console.log( "the rpc connection is down, reconnect please" );
            return;
        }
        if( oProxy.m_iState !== 2 )
        {
            console.log( "the client is not ready" );
            return;
        }

        // allocate a context object for the 'StartUpload' request
        var oContext = new Object();

        // set a callback for StartUpload
        oContext.m_oCallback = ((oContext, ret)=>{
            if( ret & 0x80000000 )
            {
                console.log( "error start upload...");
                return;
            }
            // send the file content to server
            oProxy.m_funcStreamWrite(
                oStmCtx.m_hStream,
                oStmCtx.rawData ).then((iError)=>{
                    oStmCtx.rawData = undefined;
                }).catch((iError)=> 
                {
                    if( iError !== 0 )
                        console.log( "error, uploadfile")
                });
            return
        });
        if( file.size > 0x100000 )
        {
            console.log( "this sample code limits tranfer file size less than 1MB." )
            return;
        }

        oStmCtx.m_strFile = file.name;
        oProxy.StartUpload( oContext,
            file.name,
            oStmCtx.m_hStream, 0,
            file.size,
         ).then((oContext)=>{
        }).catch((e)=>{
        })
    }
    reader.readAsArrayBuffer( file )
};


const inputElement = document.getElementById("FileToUpload");
inputElement.addEventListener("change", LoadFile, false)

var strState = "svr-greet";
globalThis.oStmCtx = oStmCtx;

globalThis.oExternalCb = (ret, oProxy)=>{
    if( ret < 0 )
        return

    // test if oProxy is in good shape
    if( oProxy.m_iState !== 2 )
        return

    // everything is fine, let's open a
    // stream channel for file transfer
    oProxy.m_funcOpenStream( oStmCtx ).then((oStmCtx)=>{
        // now oStmCtx has a handle to the stream opened
        console.log( `stream @${oStmCtx.m_hStream} is ready`);
    }).then((e)=>{
    }).catch((e)=>{
        console.log( e )
    })

}

function RemoveFile()
{
    // request to start download
    var oProxy = globalThis.oProxy;
    var oContext = new Object();
    return new Promise((resolve, reject)=>{
        oContext.m_oResolve = resolve;
        oContext.m_oReject = reject;
        return oProxy.RemoveFile( oContext,
            oStmCtx.m_strFile );
        }).then((oContext)=>{
            // the file data will come via the stream channel
            console.log( `Removed the file ${oStmCtx.m_strFile}`);
            strState = "send-file";
            // this is a synchronous call
            // oProxy.m_funcCloseStream( oStmCtx.m_hStream );
            // console.log( `closed the stream@${oStmCtx.m_hStream}`)
            oStmCtx.m_strFile = undefined;
            oStmCtx.m_qwCounter = undefined;
            oStmCtx.m_strFile = undefined;
            oStmCtx.m_qwSize = undefined;
        }).catch((oContext)=> 
        {
            strState = "error-occurred"
            if( iError !== 0 )
                console.log( "Error remove file")

            // this is a synchronous call
            oProxy.m_funcCloseStream( oStmCtx.m_hStream );
        });
}
function StartDownload()
{
    // request to start download
    var oProxy = globalThis.oProxy;
    var oContext = new Object();
    return new Promise((resolve, reject)=>{
        oContext.m_oResolve = resolve;
        oContext.m_oReject = reject;
        return oProxy.StartDownload( oContext,
            oStmCtx.m_strFile,
            oStmCtx.m_hStream,
            0, oStmCtx.m_qwSize );
        }).then((oContext)=>{
            // the file data will come via the stream channel
            console.log( "Download started...")
            console.log( oContext )
        }).catch((oContext)=> 
        {
            strState = "error-occurred"
            if( oContext.m_iRet !== 0 )
                console.log( "Error dowload file")
        });
}

function GetFileInfo( strName )
{
    var oProxy = globalThis.oProxy;
    var oContext = new Object();
    // set a callback for 'GetFileInfo'
    oContext.m_oCallback = ((oContext, ret, oFileInfo )=>{
        if( ret & 0x80000000 )
        {
            console.log( "error start upload...");
            return;
        }

        console.log( oFileInfo )

        strState = "download-file"
        oStmCtx.m_qwCounter = BigInt(0);
        oStmCtx.m_qwSize = oFileInfo.qwSize;
        oStmCtx.m_oBuf = null;
        return StartDownload()

    });
    // request the info of the file to download
    return oProxy.GetFileInfo(
        oContext, oStmCtx.m_strFile );
}

globalThis.OnStreamDataReceived = ( hStream, oBuf )=>{
    if( strState === "svr-greet")
    {
        const decoder = new TextDecoder();
        var strResp = decoder.decode( oBuf ).replace( '\0', '' )
        if( strResp !== "rdy" )
        {
            strState === "bad handshake"
            throw new Error( "Error " + strState )
        }
        console.log( "Uploading file")
        strState = 'send-file';
    }
    else if( strState === 'send-file')
    {
        const decoder = new TextDecoder();
        var strResp = decoder.decode( oBuf ).replace( '\0', '' )
        if( strResp !== "over" )
        {
            strState === "bad server response"
            throw new Error( "Error " + strState )
        }
        console.log( "Uploading file completed...")
        console.log( "getting file info...")
        strState = 'get-file-info';
        return GetFileInfo( oStmCtx.m_strFile );
    }
    else if( strState === 'download-file' )
    {
        oStmCtx.m_qwCounter += BigInt( oBuf.length );
        if( oStmCtx.m_qwCounter == oStmCtx.m_qwSize )
        {
            console.log( "Downloading file completed...");
            console.log( "test done!");
            strState = 'remove-file';
            var oProxy = globalThis.oProxy;
            // close the stream channel
            return RemoveFile();
        }
    }
    else
    {
        console.log( "Data received in wrong state");
    }
}
//# sourceURL=browsertools://custom/initenv.js
</script>
<script src="dist/sftest.js">
</script>
<script>
console.log( "hello, sftest!");
var iChecks = 0;
function checkProxyState(){
    if( globalThis.oProxy === undefined ){
        setTimeout( checkProxyState, 2000 );
        console.log( "Waiting RPC connection ready..." );
    }else if( globalThis.oProxy.m_iState === 5 ){
        console.log( "RPC connection is down..." );
        globalThis.oProxy = null;
    }else{
        if( iChecks++ === 0 )
            console.log( "RPC connection ready " + globalThis.oProxy );
        setTimeout( checkProxyState, 5000 );
    }
}
setTimeout( checkProxyState, 2000 );
//# sourceURL=browsertools://custom/rpc-entry.js
</script>
</body>
