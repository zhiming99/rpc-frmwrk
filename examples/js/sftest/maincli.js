// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// /usr/local/bin/ridlc -JO. --odesc_url=https://example.com/rpcf ../../sftest.ridl 
const { randomInt } = require( '/usr/local/etc/rpcf/./jslib/combase/defines' );
const {CoCreateInstance, RegisterFactory}=require( '/usr/local/etc/rpcf/./jslib/combase/factory' );
const {CIoManager} = require( '/usr/local/etc/rpcf/./jslib/ipc/iomgr' );

// Start the iomanager
globalThis.g_iMsgIdx = randomInt( 0xffffffff );
globalThis.CoCreateInstance=CoCreateInstance;
globalThis.RegisterFactory=RegisterFactory;
globalThis.g_oIoMgr = new CIoManager();
globalThis.g_oIoMgr.Start()


const { CConfigDb2 } = require( '/usr/local/etc/rpcf/./jslib/combase/configdb' );
const { messageType } = require( '/usr/local/etc/rpcf/./jslib/dbusmsg/constants' );
const { ERROR, Int32Value, USER_METHOD } = require( '/usr/local/etc/rpcf/./jslib/combase/defines' );
const {EnumClsid, errno, EnumPropId, EnumCallFlags, EnumTypeId, EnumSeriProto} = require( '/usr/local/etc/rpcf/./jslib/combase/enums' );
const {CSerialBase} = require( '/usr/local/etc/rpcf/./jslib/combase/seribase' );
const {CInterfaceProxy} = require( '/usr/local/etc/rpcf/./jslib/ipc/proxy' )
const {Buffer} = require( 'buffer' );
const { DBusIfName, DBusDestination2, DBusObjPath } = require( '/usr/local/etc/rpcf/./jslib/rpc/dmsg' );
const { FileInfo, } = require( './sfteststructs' );
// Start the client(s)
const { CFileTransfer_CliImpl } = require( './FileTransfercli' )

var oProxy = null;
var strObjDesc = 'https://example.com/rpcf/sftestdesc.json';
var strAppName = 'sftest';
var strFileTransferObjName = 'FileTransfer';
var oParams0 = globalThis.CoCreateInstance( EnumClsid.CConfigDb2 );
oParams0.SetString( EnumPropId.propObjInstName, 'FileTransfer' );
var oFileTransfer_cli = new CFileTransfer_CliImpl( globalThis.g_oIoMgr,
    strObjDesc, strFileTransferObjName, oParams0 );

 // start the client object
oFileTransfer_cli.Start().then((retval)=>{
    if( ERROR( retval ) )
    {
        console.log( retval );
        return;
    }
    oProxy = oFileTransfer_cli;
    /*
    * sample code to open a stream channel, it
    * can be done elsewhere when starting is complete
    var oStmCtx;
    oStmCtx.m_oProxy = oFileTransfer_cli;
    return oFileTransfer_cli.m_funcOpenStream( oStmCtx).then((oCtx)=>{
        console.log( 'OpenStream successfully with handle=' + oCtx.m_hStream );
        return Promise.resolve( oCtx );
    }).catch((oCtx)=>{
        console.log( 'OpenStream failed with error=' + oCtx.m_iRet );
        return Promise.resolve( oCtx );
    })
    */

    /*
    * sample code to make a request
    oFileTransfer_cli.StartUpload(
        strFile, hChannel, qwOffset, qwSize );
    * and the response goes to 'oFileTransfer_cli.StartUploadCallback'
    */
    
    /*
    * sample code to make a request with promise
    return new Promise( ( resolve, reject )=>{
        var oContext = new Object();
        oContext.m_oResolve = resolve;
        oContext.m_oReject = reject;
        return oFileTransfer_cli.StartUpload(
            strFile, hChannel, qwOffset, qwSize );
    }).then(( oContext)=>{
        console.log( 'request StartUpload is done with status ' + oContext.m_iRet );
    }).catch((e)=>{
        console.log(e);
    })
    */
    
    globalThis.oProxy = oProxy;
    if( globalThis.oExternalCb )
        globalThis.oExternalCb( 0, oProxy )
}).catch((e)=>{
    console.log( 'Start Proxy failed' );
    if( globalThis.oExternalCb )
        globalThis.oExternalCb( -errno.EFAULT )
    return Promise.resolve(e);
})

