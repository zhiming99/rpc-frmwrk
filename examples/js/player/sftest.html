<!--
 GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
 Copyright (C) 2025  zhiming <woodhead99@gmail.com>
 This program can be distributed under the terms of the GNU GPLv3.

* command line: /usr/local/bin/ridlc -JO. -Lcn --odesc_url=https://example.com/rpcf ../../sftest.ridl 
* npm dependency: assert browserify buffer exports minify vm envents crypto-browserify
* long lz4 process put safe-buffer stream xxhash xxhashjs webpack webpack-cli
* stream-browserify
-->
<!DOCTYPE html>
<html><head><meta charset="utf-8" /></head></html>
<body>
<p id="log">简单MP4播放器<br /></p>
<p>流程：1. 客户端通过流通道上传一个文件到服务器</p>
<p>流程：2. 客户端通过流通道再把该文件下载下来</p>
<p>流程：3. 客户端通过MediaSource播放该文件</p>
<p>注意：4. 文件名只能包含字母数字和下划线</p>
<p>注意：5. 文件最大16MB</p>
<p>注意：6. 服务器请用C++, Java, 或者Python下的例子程序“sftest”生成</p>

<label for=" file">选择文件</label>
<input id="FileToUpload" name="FileToUpload" type="file" value="Upload" >
<video controls></video>
<script src="https://bundle.run/buffer@6.0.3"></script>

<script>
// upload and download
var oStmCtx = new Object();
var arrVideoBlock = [];
function LoadFile()
{
    let file = this.files[0];

    const reader = new FileReader();

    reader.onabort     = function(e) { /* @TODO */ }
    reader.onerror     = function(e) { /* @TODO */ }
    reader.onloadstart = function(e) { /* @TODO */ }
    reader.onprogress  = function(e) { /* @TODO */ }
    reader.onload = function(e) // only triggered if successful
    {
        oStmCtx.rawData = e.target.result
        if( !oProxy )
        {
            console.log( "the rpc connection is down, reconnect please" );
            return;
        }
        if( oProxy.m_iState !== 2 )
        {
            console.log( "the client is not ready" );
            return;
        }

        // allocate a context object for the 'StartUpload' request
        var oContext = new Object();

        // set a callback for StartUpload
        oContext.m_oCallback = ((oContext, ret)=>{
            if( ret & 0x80000000 )
            {
                console.log( "error start upload...");
                return;
            }
            // send the file content to server
            oProxy.m_funcStreamWrite(
                oStmCtx.m_hStream,
                oStmCtx.rawData ).then((iError)=>{
                    oStmCtx.rawData = undefined;
                }).catch((iError)=> 
                {
                    if( iError !== 0 )
                        console.log( "error, uploadfile")
                });
            return
        });
        if( file.size > 0x1000000 )
        {
            console.log( "this sample code limits tranfer file size less than 16MB." )
            return;
        }

        oStmCtx.m_strFile = file.name;
        oProxy.StartUpload( oContext,
            file.name,
            oStmCtx.m_hStream, 0,
            file.size,
         ).then((oContext)=>{
        }).catch((e)=>{
        })
    }
    reader.readAsArrayBuffer( file )
};


const inputElement = document.getElementById("FileToUpload");
inputElement.addEventListener("change", LoadFile, false)

var strState = "svr-greet";
globalThis.oStmCtx = oStmCtx;

globalThis.oExternalCb = (ret, oProxy)=>{
    if( ret < 0 )
        return

    // test if oProxy is in good shape
    if( oProxy.m_iState !== 2 )
        return

    // everything is fine, let's open a
    // stream channel for file transfer
    oProxy.m_funcOpenStream( oStmCtx ).then((oStmCtx)=>{
        // now oStmCtx has a handle to the stream opened
        console.log( `stream @${oStmCtx.m_hStream} is ready`);
    }).then((e)=>{
    }).catch((e)=>{
        console.log( e )
    })
}

function RemoveFile()
{
    // request to start download
    var oProxy = globalThis.oProxy;
    var oContext = new Object();
    return new Promise((resolve, reject)=>{
        oContext.m_oResolve = resolve;
        oContext.m_oReject = reject;
        return oProxy.RemoveFile( oContext,
            oStmCtx.m_strFile );
        }).then((oContext)=>{
            // the file data will come via the stream channel
            console.log( `Removed the remote file ${oStmCtx.m_strFile}`);
            strState = "send-file";
            // this is a synchronous call
            // oProxy.m_funcCloseStream( oStmCtx.m_hStream );
            // console.log( `closed the stream@${oStmCtx.m_hStream}`)
            oStmCtx.m_strFile = undefined;
            oStmCtx.m_qwCounter = undefined;
            oStmCtx.m_strFile = undefined;
            oStmCtx.m_qwSize = undefined;
            var oBuf = buffer.Buffer.concat(arrVideoBlock)
            arrVideoBlock = [];
            arrVideoBlock.push(oBuf)
            startPlay();
        }).catch((oContext)=> 
        {
            strState = "error-occurred"
            if( iError !== 0 )
                console.log( "Error remove file")

            // this is a synchronous call
            oProxy.m_funcCloseStream( oStmCtx.m_hStream );
        });
}
function StartDownload()
{
    // request to start download
    var oProxy = globalThis.oProxy;
    var oContext = new Object();
    return new Promise((resolve, reject)=>{
        oContext.m_oResolve = resolve;
        oContext.m_oReject = reject;
        return oProxy.StartDownload( oContext,
            oStmCtx.m_strFile,
            oStmCtx.m_hStream,
            0, oStmCtx.m_qwSize );
        }).then((oContext)=>{
            // the file content will be received by
            // OnStreamDataReceived
            console.log( "Download started...")
            console.log( oContext )
        }).catch((oContext)=> 
        {
            strState = "error-occurred"
            if( oContext.m_iRet !== 0 )
                console.log( "Error dowload file")
        });
}

function GetFileInfo( strName )
{
    var oProxy = globalThis.oProxy;
    var oContext = new Object();
    // set a callback for 'GetFileInfo'
    oContext.m_oCallback = ((oContext, ret, oFileInfo )=>{
        if( ret & 0x80000000 )
        {
            console.log( "error start upload...");
            return;
        }

        console.log( oFileInfo )

        strState = "download-file"
        oStmCtx.m_qwCounter = BigInt(0);
        oStmCtx.m_qwSize = oFileInfo.qwSize;
        oStmCtx.m_oBuf = null;
        return StartDownload()

    });
    // request the info of the file to download
    return oProxy.GetFileInfo(
        oContext, oStmCtx.m_strFile );
}

globalThis.OnStreamDataReceived = ( hStream, oBuf )=>{
    if( strState === "svr-greet")
    {
        const decoder = new TextDecoder();
        var strResp = decoder.decode( oBuf ).replace( '\0', '' )
        if( strResp !== "rdy" )
        {
            strState === "bad handshake"
            throw new Error( "Error " + strState )
        }
        console.log( "Uploading file")
        strState = 'send-file';
    }
    else if( strState === 'send-file')
    {
        const decoder = new TextDecoder();
        var strResp = decoder.decode( oBuf ).replace( '\0', '' )
        if( strResp !== "over" )
        {
            strState === "bad server response"
            throw new Error( "Error " + strState )
        }
        console.log( "Uploading file completed...")
        console.log( "getting file info...")
        strState = 'get-file-info';
        return GetFileInfo( oStmCtx.m_strFile );
    }
    else if( strState === 'download-file' )
    {
        oStmCtx.m_qwCounter += BigInt( oBuf.length );
        arrVideoBlock.push( oBuf )

        if( oStmCtx.m_qwCounter == oStmCtx.m_qwSize )
        {
            console.log( "Downloading file completed...");
            console.log( "test done!");
            strState = 'remove-file';
            var oProxy = globalThis.oProxy;
            // close the stream channel
            return RemoveFile();
        }
    }
    else
    {
        console.log( "Data received in wrong state");
    }
}
//# sourceURL=browsertools://custom/initenv.js
</script>
<script src="dist/sftest.js">
<p id="rpcf_load_notify"><br /></p>
</script>
<script>
globalThis.g_bAuth = false
globalThis.g_strAuthMech = ""
console.log( "hello, sftest!");
var iChecks = 0;
function checkProxyState(){
    if( globalThis.oProxy === undefined ){
        setTimeout( checkProxyState, 2000 );
        console.log( "Waiting RPC connection ready..." );
    }else if( globalThis.oProxy === null ){
        console.log( "RPC connection is shutdown abnormally..." );
    }else if( globalThis.oProxy.m_iState === 5 ){
        console.log( "RPC connection is down..." );
        globalThis.oProxy = null;
    }else{
        if( iChecks++ === 0 )
            console.log( "RPC connection ready " + globalThis.oProxy );
        setTimeout( checkProxyState, 5000 );
    }
}
setTimeout( checkProxyState, 2000 );
//# sourceURL=rpcf://htmlcode/checkstate.js
</script>

<script>
// player
var videoBuffer = null
// var mimeCodec = 'audio/mp4; codecs="mp4a.40.2"';
var mimeCodec = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
function registerPlayer(mediaSource) {
    videoBuffer = mediaSource.addSourceBuffer( mimeCodec );
    let countDownloadChunk = 0
    var appendbuf = function(){
        if( arrVideoBlock.length > 0 )
        {
            console.log( "adding buffer...")
            var buf = arrVideoBlock.shift();
            countDownloadChunk++
            videoBuffer.appendBuffer(buf);
        }
        else
        {
            mediaSource.endOfStream();
            var playPromise = myAudio.play();
            if (playPromise !== undefined) {
                // to make chrome happy
                playPromise.then(function() {
                }).catch(function(error) {
                    console.log( error )
                });
            }
        }
    }

    videoBuffer.addEventListener("updateend", appendbuf );

    if( arrVideoBlock.length)
    {
        videoBuffer.appendBuffer( arrVideoBlock.shift() );
    }
    else
    {
        var id = setInterval(() => {
            if( arrVideoBlock.length )
            {
                countDownloadChunk++;
                videoBuffer.appendBuffer(arrVideoBlock.shift());
                clearInterval( id );
            }
        }, 1000);
    }
}

function processStream(mediaSource) {
    registerPlayer(mediaSource)
}

var myAudio = null;
var mediaSource = null;
function startPlay()
{
    if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) 
    {
        myAudio = document.querySelector('video');
        mediaSource = new MediaSource();
        mediaSource.addEventListener('sourceopen', ()=>{
            processStream(mediaSource);
        });
        myAudio.src = URL.createObjectURL(mediaSource);
    }
    else
    {
        console.error( "Unsupported mime type " , mimeCodec)
    }
}
//# sourceURL=browsertools://custom/player.js
</script>

</body>
