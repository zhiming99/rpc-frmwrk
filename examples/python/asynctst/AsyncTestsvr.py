#Generated by RIDLC, make sure to backup before running RIDLC again
from typing import Tuple
from rpcf.rpcbase import *
from rpcf.proxy import *
from seribase import CSerialBase
from asynctststructs import *
import errno

from AsyncTestsvrbase import *
class CIAsyncTestsvr( IIAsyncTest_SvrImpl ):
    
    def LongWaitCb( self, oReqCtx : PyReqContext ) :
        #timer callback, complete the request
        context = oReqCtx.oContext
        strText = context[ 1 ]
        context = None
        self.OnLongWaitComplete(
            oReqCtx, 0, strText )
        OutputMsg( "LongWait request completed " )
        return
        
    '''
    Asynchronous request handler
    '''
    def LongWait( self, oReqCtx : PyReqContext,
        i0 : str
        ) -> Tuple[ int, list ] :
        '''
        the response parameters includes
        i0r : str
        '''
        OutputMsg( "proxy says '%s' " % i0 )
        ret = self.AddTimer( 3,
            CIAsyncTestsvr.LongWaitCb,
            oReqCtx )

        if ret[ 0 ] < 0 :
            return [ ret[ 0 ],  ]

        # store timerObj to the oReqCtx so that
        # we can use it in the complete callback
        timerObj = ret[ 1 ]
        oReqCtx.oContext = [ timerObj, i0 ]

        # return pending, and wait for TimerCallback
        return [ 65537, ]
        
    '''
    This method is called when the async
    request is cancelled due to timeout
    or user request. Add your own cleanup
    code here
    '''
    def OnLongWaitCanceled( self,
        oReqCtx : PyReqContext, iRet : int,
        i0 : str ):
        if oReqCtx.oContext is not None:
            timerObj = oReqCtx.oContext[ 0 ]
            ret = self.DisableTimer( timerObj )
            OutputMsg( "timer removed " + str( ret ) )
            oReqCtx.oContext = None
            OutputMsg( "LongWait request canceled with " + i0 )
        
    '''
    Synchronous request handler
    '''
    def LongWaitNoParam( self, oReqCtx : PyReqContext
        ) -> Tuple[ int, None ] :
        return [ 0, None ]
        
    def LongWait2Cb( self, oReqCtx, i1r ):
        try:
            OutputMsg( "LongWait2Cb request complete with " + i1r)
            self.OnLongWait2Complete( oReqCtx, 0, i1r )
        except Exception as e:
            OutputMsg(str(e))
    '''
    Asynchronous request handler
    '''
    def LongWait2( self, oReqCtx : PyReqContext,
        i1 : str
        ) -> Tuple[ int, list ] :
        '''
        the response parameters includes
        i1r : str
        '''
        OutputMsg( "LongWait2 deferred a call" )
        #Another way of asynchronous processing
        ret = self.DeferCall(
            CIAsyncTestsvr.LongWait2Cb, oReqCtx, i1 )
        if ret < 0 :
            OutputMsg("DeferCall failed with error " + ret )
            return [ ret, None ]
        #return pending to wait for LongWait2Cb
        return [ 65537, ]
        
    '''
    This method is called when the async
    request is cancelled due to timeout
    or user request. Add your own cleanup
    code here
    '''
    def OnLongWait2Canceled( self,
        oReqCtx : PyReqContext, iRet : int,
        i1 : str ):
        OutputMsg( "OnLongWait2Canceled entered " + str(iRet))
        
    
class CAsyncTestServer(
    CIAsyncTestsvr,
    PyRpcServer ) :
    def __init__( self, pIoMgr, strDesc, strObjName ) :
        PyRpcServer.__init__( self,
            pIoMgr, strDesc, strObjName )
