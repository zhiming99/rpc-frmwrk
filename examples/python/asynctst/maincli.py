# GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
# Copyright (C) 2024  zhiming <woodhead99@gmail.com>
# This program can be distributed under the terms of the GNU GPLv3.
# ridlc -pO . ../../asynctst.ridl 
from typing import Tuple
from rpcf.rpcbase import *
from rpcf.proxy import *
from seribase import CSerialBase
from asynctststructs import *
import errno

from AsyncTestcli import CAsyncTestProxy
import os
import time

import signal
bExit = False
def SigHandler( signum, frame ):
    global bExit
    bExit = True


def MainEntryCli() :
    ret = 0
    signal.signal( signal.SIGINT, SigHandler)
    oContext = PyRpcContext( 'PyRpcProxy' )
    with oContext as ctx:
        if ctx.status < 0:
            ret = ctx.status
            print( os.getpid(), 
                "Error start PyRpcContext %d" % ret )
            return ret
        
        print( "start to work here..." )
        strPath_ = os.path.dirname( os.path.realpath( __file__ ) )
        strPath_ += '/asynctstdesc.json'
        oProxy_AsyncTest = CAsyncTestProxy( ctx.pIoMgr,
            strPath_, 'AsyncTest' )
        ret = oProxy_AsyncTest.GetError()
        if ret < 0 :
            return ret
        
        with oProxy_AsyncTest as oProxy:
            global bExit
            try:
                ret = oProxy.GetError()
                if ret < 0 :
                    raise Exception( 'start proxy failed' )
                state = oProxy.oInst.GetState()
                while state == cpp.stateRecovery :
                    time.sleep( 1 )
                    state = oProxy.oInst.GetState()
                    if bExit:
                        break
                if state != cpp.stateConnected or bExit:
                    return ErrorCode.ERROR_STATE
                ret = maincli( oProxy )
            except Exception as err:
                print( err )
            
        oProxy_AsyncTest = None
    oContext = None
    return ret
    
#------customize the method below for your own purpose----
def maincli( 
    oProxy: CAsyncTestProxy ) -> int:
    while True:
        i0 = "hello, LongWait"
        ctx = object()
        pret = oProxy.LongWait( ctx, i0 )
        if pret[ 0 ] < 0 :
            ret = pret[ 0 ]
            print( "LongWait failed with error " + str(ret) )
            break
        if pret[ 0 ] == ErrorCode.STATUS_PENDING:
            oProxy.WaitForComplete()
            ret = oProxy.GetError()
            if ret == 0 :
                print( "LongWait completed successfully" )
            else :
                print( "LongWait failed with error " +
                    str(ret) )
        else :
            print( "LongWait completed immediately " +
                pret[ 1 ][ 0 ] )
            
        pret = oProxy.LongWaitNoParam( "no context" )
        if pret[ 0 ] < 0:    
            ret = pret[ 0 ]
            print( "LongWaitNoParam failed with error " +
                str(ret) )
            break

        if pret[ 0 ] == 65537 :
            oProxy.WaitForComplete()
            ret = oProxy.GetError()
            if ret == 0 :
                print( "LongWaitNoParam completed" )
            else :
                print( "LongWaitNoParam failed with error " +
                    str(ret) )
        else :
            print( "LongWaitNoParam complete with " +
                pret[ 1 ][ 0 ] )
                
        i0 = "hello, LongWait2"
        pret = oProxy.LongWait2( i0 )    
        if pret[ 0 ] < 0 :
            ret = pret[ 0 ]
            print( "LongWait2 failed with error " + str(ret) )
            break
        print( "LongWait2 completed with response " +
            pret[ 1 ][ 0 ] )
        ret = 0
        break
    return 0
    
if __name__ == '__main__' :
    ret = MainEntryCli()
    quit( -ret )
