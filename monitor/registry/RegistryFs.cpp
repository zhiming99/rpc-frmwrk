// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2024  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -O . -I ../registry -l regfs.ridl 
#include "rpc.h"
#include "iftasks.h"
#include "RegistryFs.h"

namespace rpcf
{

gint32 TimeSpec::Serialize( BufPtr& pBuf_ )
{
    if( pBuf_.IsEmpty() )
        return -EINVAL;
    gint32 ret = 0;
    do{
        ret = CSerialBase::Serialize(
            pBuf_, m_dwMsgId );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, tv_sec );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, tv_nsec );
        if( ERROR( ret ) ) break;
        
    }while( 0 );

    return ret;
    
}

gint32 TimeSpec::Deserialize( BufPtr& pBuf_ )
{
    if( pBuf_.IsEmpty() )
        return -EINVAL;
    gint32 ret = 0;
    do{
        guint32 dwMsgId = 0;
        ret = CSerialBase::Deserialize(
            pBuf_, dwMsgId );
        
        if( ERROR( ret ) ) return ret;
        if( m_dwMsgId != dwMsgId ) return -EINVAL;
        
        ret = CSerialBase::Deserialize(
            pBuf_, tv_sec );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, tv_nsec );
        
        if( ERROR( ret ) ) break;
        
    }while( 0 );

    return ret;
    
}

TimeSpec& TimeSpec::operator=(
    const TimeSpec& rhs )
{
    do{
        // data members
        if( GetObjId() == rhs.GetObjId() )
            break;
        
        tv_sec = rhs.tv_sec;
        tv_nsec = rhs.tv_nsec;
        
    }while( 0 );

    return *this;
}

gint32 FileStat::Serialize( BufPtr& pBuf_ )
{
    if( pBuf_.IsEmpty() )
        return -EINVAL;
    gint32 ret = 0;
    do{
        ret = CSerialBase::Serialize(
            pBuf_, m_dwMsgId );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_dev );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_ino );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_mode );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_nlink );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_uid );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_gid );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_rdev );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_size );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_blksize );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_blocks );
        if( ERROR( ret ) ) break;
        
        st_atim.SetIf( GetIf() );
        ret = SerialStruct( 
            pBuf_, st_atim );
        if( ERROR( ret ) ) break;
        
        st_mtim.SetIf( GetIf() );
        ret = SerialStruct( 
            pBuf_, st_mtim );
        if( ERROR( ret ) ) break;
        
        st_ctim.SetIf( GetIf() );
        ret = SerialStruct( 
            pBuf_, st_ctim );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_name );
        if( ERROR( ret ) ) break;
        
    }while( 0 );

    return ret;
    
}

gint32 FileStat::Deserialize( BufPtr& pBuf_ )
{
    if( pBuf_.IsEmpty() )
        return -EINVAL;
    gint32 ret = 0;
    do{
        guint32 dwMsgId = 0;
        ret = CSerialBase::Deserialize(
            pBuf_, dwMsgId );
        
        if( ERROR( ret ) ) return ret;
        if( m_dwMsgId != dwMsgId ) return -EINVAL;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_dev );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_ino );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_mode );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_nlink );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_uid );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_gid );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_rdev );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_size );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_blksize );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_blocks );
        
        if( ERROR( ret ) ) break;
        
        st_atim.SetIf( GetIf() );
        ret = DeserialStruct(
            pBuf_, st_atim );
        if( ERROR( ret ) ) break;
        
        st_mtim.SetIf( GetIf() );
        ret = DeserialStruct(
            pBuf_, st_mtim );
        if( ERROR( ret ) ) break;
        
        st_ctim.SetIf( GetIf() );
        ret = DeserialStruct(
            pBuf_, st_ctim );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_name );
        
        if( ERROR( ret ) ) break;
        
    }while( 0 );

    return ret;
    
}

FileStat& FileStat::operator=(
    const FileStat& rhs )
{
    do{
        // data members
        if( GetObjId() == rhs.GetObjId() )
            break;
        
        st_dev = rhs.st_dev;
        st_ino = rhs.st_ino;
        st_mode = rhs.st_mode;
        st_nlink = rhs.st_nlink;
        st_uid = rhs.st_uid;
        st_gid = rhs.st_gid;
        st_rdev = rhs.st_rdev;
        st_size = rhs.st_size;
        st_blksize = rhs.st_blksize;
        st_blocks = rhs.st_blocks;
        st_atim = rhs.st_atim;
        st_mtim = rhs.st_mtim;
        st_ctim = rhs.st_ctim;
        st_name = rhs.st_name;
        
    }while( 0 );

    return *this;
}

gint32 IIRegFsLocal_SImpl::InitUserFuncs()
{
    BEGIN_IFHANDLER_MAP( IRegFsLocal );

    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::CreateFileWrapper,
        "CreateFile" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::MakeDirWrapper,
        "MakeDir" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::OpenFileWrapper,
        "OpenFile" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::CloseFileWrapper,
        "CloseFile" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::RemoveFileWrapper,
        "RemoveFile" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::ReadFileWrapper,
        "ReadFile" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::WriteFileWrapper,
        "WriteFile" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::TruncateWrapper,
        "Truncate" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::CloseDirWrapper,
        "CloseDir" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::RemoveDirWrapper,
        "RemoveDir" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::SetGidWrapper,
        "SetGid" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::SetUidWrapper,
        "SetUid" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::GetGidWrapper,
        "GetGid" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::GetUidWrapper,
        "GetUid" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::SymLinkWrapper,
        "SymLink" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::GetValueWrapper,
        "GetValue" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::SetValueWrapper,
        "SetValue" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::ChmodWrapper,
        "Chmod" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::ChownWrapper,
        "Chown" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::ReadLinkWrapper,
        "ReadLink" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::RenameWrapper,
        "Rename" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::FlushWrapper,
        "Flush" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::AccessWrapper,
        "Access" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::GetAttrWrapper,
        "GetAttr" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::ReadDirWrapper,
        "ReadDir" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::OpenDirWrapper,
        "OpenDir" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsLocal_SImpl::ExecBatWrapper,
        "ExecBat" );
    
    END_IFHANDLER_MAP;
    
    return STATUS_SUCCESS;
}

gint32 IIRegFsLocal_SImpl::CreateFileWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 dwMode;
    guint32 dwFlags;
    guint64 hFile;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwMode );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwFlags );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = CreateFile(
        strPath,
        dwMode,
        dwFlags,
        hFile );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(this);
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, hFile );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::MakeDirWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 dwMode;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwMode );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = MakeDir(
        strPath,
        dwMode );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::OpenFileWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 dwFlags;
    guint64 hFile;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwFlags );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = OpenFile(
        strPath,
        dwFlags,
        hFile );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(this);
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, hFile );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::CloseFileWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    guint64 hFile;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, hFile );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = CloseFile(
        hFile );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::RemoveFileWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = RemoveFile(
        strPath );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::ReadFileWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    guint64 hFile;
    guint32 dwSize;
    guint32 dwOff;
    BufPtr buffer;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, hFile );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwSize );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwOff );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = ReadFile(
        hFile,
        dwSize,
        dwOff,
        buffer );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(this);
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, buffer );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::WriteFileWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    guint64 hFile;
    BufPtr buffer;
    guint32 dwOff;
    guint32 dwSizeWrite;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, hFile );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, buffer );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwOff );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = WriteFile(
        hFile,
        buffer,
        dwOff,
        dwSizeWrite );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(this);
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, dwSizeWrite );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::TruncateWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    guint64 hFile;
    guint32 dwOff;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, hFile );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwOff );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = Truncate(
        hFile,
        dwOff );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::CloseDirWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    guint64 hFile;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, hFile );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = CloseDir(
        hFile );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::RemoveDirWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = RemoveDir(
        strPath );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::SetGidWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 wGid;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, wGid );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = SetGid(
        strPath,
        wGid );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::SetUidWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 wUid;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, wUid );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = SetUid(
        strPath,
        wUid );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::GetGidWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 gid;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = GetGid(
        strPath,
        gid );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(this);
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, gid );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::GetUidWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 uid;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = GetUid(
        strPath,
        uid );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(this);
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, uid );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::SymLinkWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strSrcPath;
    std::string strDestPath;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strSrcPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, strDestPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = SymLink(
        strSrcPath,
        strDestPath );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::GetValueWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    std::string strJson;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = GetValue(
        strPath,
        strJson );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(this);
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, strJson );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::SetValueWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    std::string strJson;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, strJson );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = SetValue(
        strPath,
        strJson );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::ChmodWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 dwMode;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwMode );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = Chmod(
        strPath,
        dwMode );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::ChownWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 dwUid;
    guint32 dwGid;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwUid );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwGid );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = Chown(
        strPath,
        dwUid,
        dwGid );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::ReadLinkWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    BufPtr buf;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = ReadLink(
        strPath,
        buf );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(this);
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, buf );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::RenameWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string szFrom;
    std::string szTo;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, szFrom );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, szTo );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = Rename(
        szFrom,
        szTo );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::FlushWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    guint32 dwFlags;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, dwFlags );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = Flush(
        dwFlags );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::AccessWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 dwFlags;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwFlags );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = Access(
        strPath,
        dwFlags );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::GetAttrWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    FileStat oStat;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = GetAttr(
        strPath,
        oStat );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(this);
        CSerialBase oSerial_( pSerialIf_ );
        do{
            oStat.SetIf( oSerial_.GetIf() );
            ret = oSerial_.SerialStruct( 
                pBuf2, oStat );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::ReadDirWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    guint64 hDir;
    std::vector<FileStat> vecDirEnt;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, hDir );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = ReadDir(
        hDir,
        vecDirEnt );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(this);
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.SerializeArray(
                pBuf2, vecDirEnt, "(O)" );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::OpenDirWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 dwFlags;
    guint64 hDir;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwFlags );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = OpenDir(
        strPath,
        dwFlags,
        hDir );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(this);
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, hDir );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIRegFsLocal_SImpl::ExecBatWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strJson;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strJson );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = ExecBat(
        strJson );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

}
