// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2025  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ../../../../ridl/.libs/ridlc -m timer1 --server -sO . ./apptimer.ridl 
#include "rpc.h"
#include "proxy.h"
using namespace rpcf;
#include "stmport.h"
#include "fastrpc.h"
#include "AppManagercli.h"
#include "frmwrk.h"
#include "monconst.h"

ObjPtr g_pIoMgr;
#include <signal.h>
#include <stdlib.h>
#include <limits.h>

static std::atomic< bool > g_bExit( false );
static bool g_bLogging = false;
static stdstr g_strAppInst = "timer1";

void SignalHandler( int signum )
{
    if( signum == SIGINT )
        g_bExit = true;
    else if( signum == SIGUSR1 )
        OutputMsg( 0,
            "remote connection is down" );
}

std::atomic< guint32 > g_dwInterval( 10 );

struct CAsyncTimerCallbacks : public CAsyncStdAMCallbacks
{
    typedef CAsyncStdAMCallbacks super;

    gint32 GetPointValuesToUpdate(
        InterfPtr& pIf,
        std::vector< KeyValue >& veckv ) override
   {
        gint32 ret = 0;
        KeyValue okv;
        okv.strKey = O_PID;
        okv.oValue = ( guint32 )getpid();
        veckv.push_back( okv );

        okv.strKey = O_OBJ_COUNT;
        okv.oValue = ( guint32 )
            CObjBase::GetActCount();
        veckv.push_back( okv );
        return ret;
   }

    gint32 SetPointValuesCallback( 
        IConfigDb* context, gint32 iRet )
    {
        if( context == nullptr )
            return 0;
        if( SUCCEEDED( iRet ) )
            return 0;

        gint32 ret = 0;
        do{
            InterfPtr pProxy;
            ret = GetAppManagercli( pProxy );
            if( ERROR( ret ) )
                break;
            CAppManager_CliImpl* pam = pProxy;
            CCfgOpener oCtx( context );
            stdstr strApp;
            ret = oCtx.GetStrProp(
                propObjName, strApp );
            if( ERROR( ret ) )
                break;
            if( ERROR( iRet ) )
            {
                LOGWARN( pam->GetIoMgr(), iRet,
                "Warning, failed to update '%s' "
                "offline counters",
                strApp.c_str() );
            }
        }while( 0 );
        return 0;
    }


    void CalOfflineCounters( 
        const std::vector< KeyValue >& arrKvs,
        std::vector< KeyValue >& vecKvs )
    {
        Variant rxb( ( guint64 )0 );
        Variant txb( ( guint64 )0 );
        Variant offl( ( guint32 )0 );
        Variant uptime( ( guint32 )0 );
        for( auto& elem : arrKvs )
        {
            if( elem.strKey == "rx_bytes" ||
                elem.strKey == "rx_bytes_total" )
            {
                ( ( guint64& )rxb ) += ( guint64& )elem.oValue;
                DebugPrint( 0, "rxb = %lx", ( guint64& )rxb );
            }
            else if( elem.strKey == "tx_bytes" ||
                elem.strKey == "tx_bytes_total" )
            {
                ( ( guint64& )txb ) += ( guint64& )elem.oValue;
                DebugPrint( 0, "txb = %lx", ( guint64& )txb );
            }
            else if( elem.strKey == "uptime_total" ||
                elem.strKey == "uptime" )
            {
                ( ( guint32& )uptime ) += ( guint32& )elem.oValue;
                DebugPrint( 0, "uptime = %x", ( guint32& )uptime );
            }
            else if( elem.strKey == "offline_times" )
            {
                ( ( guint32& )offl ) += ( guint32& )elem.oValue + 1;
                DebugPrint( 0, "offline_times = %x", ( guint32& )uptime );
            }
        }
        KeyValue okv;
        okv.strKey = "rx_bytes_total";
        okv.oValue = rxb;
        vecKvs.emplace_back( okv );
        okv.strKey = "tx_bytes_total";
        okv.oValue = txb;
        vecKvs.emplace_back( okv );
        okv.strKey = "offline_times";
        okv.oValue = offl;
        vecKvs.emplace_back( okv );
        okv.strKey = "uptime_total";
        okv.oValue = uptime;
        vecKvs.emplace_back( okv );
    }

    gint32 GetPointValuesCallback(
        IConfigDb* context, gint32 iRet,
        std::vector<KeyValue>& arrKeyVals /*[ In ]*/ )
    {
        if( ERROR( iRet ) )
            return iRet;
        gint32 ret = 0;
        do{
            InterfPtr pProxy;
            ret = GetAppManagercli( pProxy );
            if( ERROR( ret ) )
                break;
            CAppManager_CliImpl* pam = pProxy;

            std::vector< KeyValue > vecKvs;
            CalOfflineCounters(
                arrKeyVals, vecKvs );
            if( vecKvs.empty() )
                break;

            stdstr strApp;
            CCfgOpener oCtx( context );
            ret = oCtx.GetStrProp(
                propObjName, strApp );
            if( ERROR( ret ) )
                break;

            ret = pam->SetPointValues(
                context, strApp, vecKvs );
        }while( 0 );
        return ret;
    }


    gint32 UpdateOfflineCounters(
        const stdstr& strApp )
    {
        if( strApp.empty() )
            return -EINVAL;
        gint32 ret = 0;
        do{
            InterfPtr pProxy;
            ret = GetAppManagercli( pProxy );
            if( ERROR( ret ) )
                break;
            CAppManager_CliImpl* pam = pProxy;

            std::vector< stdstr > vecPoints = {
                "rx_bytes",
                "rx_bytes_total",
                "tx_bytes",
                "tx_bytes_total",
                "uptime",
                "uptime_total",
                "offline_times" };
            std::vector< KeyValue > arrKvs, newKvs;
            CCfgOpener oContext;
            oContext.SetStrProp( propObjName, strApp );
            ret = pam->GetPointValues(
                oContext.GetCfg(),
                strApp, vecPoints, arrKvs );
            if( ret == STATUS_PENDING )
                break;
            if( ERROR( ret ) )
                break;

            if( arrKvs.empty() )
            {
                ret = -ENOENT;
                break;
            }

            CalOfflineCounters( arrKvs, newKvs );
            if( newKvs.empty() )
            {
                ret = -ENOENT;
                break;
            }
            ret = pam->SetPointValues(
                oContext.GetCfg(),
                strApp, newKvs );

        }while( 0 );
        return ret;
    }
    //RPC event handler 'OnPointChanged'
    gint32 OnPointChanged(
        IConfigDb* context, 
        const std::string& strPtPath /*[ In ]*/,
        const Variant& value /*[ In ]*/ ) override
    {
        do{
            if( strPtPath ==
                g_strAppInst + "/interval1" )
            {
                guint32 dwWaitSec = value;
                if( dwWaitSec> 3600 )
                    break;

                g_dwInterval = dwWaitSec;
                OutputMsg( 0,
                    "interval changed to %d",
                    dwWaitSec );
            }
            else if( strPtPath ==
                g_strAppInst + "/offline_action" )
            {
                UpdateOfflineCounters( value );
            }
            else
            {
                super::OnPointChanged(
                    context, strPtPath, value );
            }
            break;
        }while( 0 );
        return 0;
    }

};

gint32 InitContext()
{
    gint32 ret = CoInitialize( 0 );
    if( ERROR( ret ) )
        return ret;
    do{
        CParamList oParams;
        oParams.Push( "appmonsvr" );
        oParams[ propSearchLocal ] = false;
        oParams[ propEnableLogging ] = g_bLogging;

        // adjust the thread number if necessary
        oParams[ propMaxIrpThrd ] = 0;
        oParams[ propMaxTaskThrd ] = 4;
        
        ret = g_pIoMgr.NewObj(
            clsid( CIoManager ), 
            oParams.GetCfg() );
        if( ERROR( ret ) )
            break;

        CIoManager* pSvc = g_pIoMgr;
        ret = pSvc->Start();
        if( ERROR( ret ) )
            break;
    }while( 0 );

    return ret;
}

gint32 DestroyContext()
{
    IService* pSvc = g_pIoMgr;
    if( pSvc != nullptr )
    {
        pSvc->Stop();
        g_pIoMgr.Clear();
    }

    CoUninitialize();
    DebugPrintEx( logErr, 0,
        "#Leaked objects is %d",
        CObjBase::GetActCount() );
    return STATUS_SUCCESS;
}

static void Usage( const char* szName )
{
    fprintf( stderr,
        "Usage: %s [OPTIONS] <mount point> \n"
        "\t [ -d to run as a daemon ]\n"
        "\t [ -n <appinst name> specify an alternative apptimer instance, default 'timer1' ]\n"
        "\t [ -g send logs to log server ]\n"
        "\t [ -h this help ]\n", szName );
}

gint32 TimerLoop();

int main( int argc, char** argv )
{
    gint32 ret = 0;
    do{
        bool bDaemon = false;
        int opt = 0;
        while( ( opt = getopt( argc, argv, "hdgn:" ) ) != -1 )
        {
            switch( opt )
            {
                case 'd':
                    { bDaemon = true; break; }
                case 'g':
                    { g_bLogging = true; break; }
                case 'n':
                    {
                        g_strAppInst = optarg;
                        if( !IsValidName( g_strAppInst ) )
                        {
                            printf( "Error, bad app instance name" );
                            ret = -EINVAL;
                        }
                        break;
                    }
                case 'h':
                default:
                    { Usage( argv[ 0 ] ); exit( 0 ); }
            }
        }
        if( ERROR( ret ) )
            break;

        if( bDaemon )
        {
            ret = daemon( 1, 0 );
            if( ret < 0 )
            { ret = -errno; break; }
        }

        ret = InitContext();
        if( ERROR( ret ) )
            break;
        
        CIoManager* pMgr = g_pIoMgr;
        ret = pMgr->TryLoadClassFactory(
            "libappmancli.so" );
        if( ERROR( ret ) )
            break;

        stdstr strCmdLine(
            SimpleCmdLine( argc, argv ) );
        pMgr->SetCmdLineOpt(
            propCmdLine, strCmdLine );

        InterfPtr pIf;
        PACBS pacbsIn( new CAsyncTimerCallbacks );
        InterfPtr pAppMan;
        // the pIf is just a placeholder, not for real.
        pIf = pMgr->GetSyncIf();
        ret = StartStdAppManCli(
            pIf, g_strAppInst, pAppMan, pacbsIn );
        if( ERROR( ret ) )
            break;
        
        if( SUCCEEDED( ret ) )
            ret = TimerLoop();
            
        StopStdAppManCli();
    }while( 0 );

    DestroyContext();
    return ret;
}

// Function to wait for a specified number of seconds
// (supports fractional seconds)
void WaitForSeconds(double seconds)
{
    struct timeval tv;
    // Extract integer part of seconds
    tv.tv_sec = static_cast<int>(seconds);
    // Extract fractional part of seconds
    tv.tv_usec = static_cast<int>((seconds - tv.tv_sec) * 1e6);
    select(0, nullptr, nullptr, nullptr, &tv);
}

//-----Your code begins here---
gint32 TimerLoop()
{
    gint32 ret = 0;
    auto iOldSig = 
        signal( SIGINT, SignalHandler );
    signal( SIGUSR1, SignalHandler );

    guint32 dwTicks = 0;
    while( !g_bExit )
    {
        dwTicks++;
        InterfPtr pProxy;
        ret = GetAppManagercli( pProxy );
        if( ERROR( ret ) )
        {
            ret = 0;
            WaitForSeconds( 1 );
            continue;
        }
        CAppManager_CliImpl* pam = pProxy;

        CCfgOpener oCfg;
        if( dwTicks % g_dwInterval )
        {
            WaitForSeconds( 1 );
            continue;
        }
        oCfg.SetIntProp( propContext, 2 );
        Variant var( ( guint32 )1);
        pam->SetPointValue( oCfg.GetCfg(),
            g_strAppInst + "/clock1", var );
        OutputMsg( 0, 
            "Info send clock1 %d",
            dwTicks );

        WaitForSeconds( 1 );
    }

    ret = STATUS_SUCCESS;

    signal( SIGINT, iOldSig );
    return ret;
}

