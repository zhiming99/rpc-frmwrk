// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2025  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ../../../../ridl/.libs/ridlc -m timer1 --server -sO . ./apptimer.ridl 
#include "rpc.h"
#include "proxy.h"
using namespace rpcf;
#include "stmport.h"
#include "fastrpc.h"
#include "AppManagercli.h"
#include "frmwrk.h"
#include "monconst.h"

ObjPtr g_pIoMgr;
#include <signal.h>
#include <stdlib.h>
#include <limits.h>
#include "cronexpr.h"

static std::atomic< bool > g_bExit( false );
static bool g_bLogging = false;
static stdstr g_strAppInst = "timer1";
static TaskletPtr g_pSyncTask;

void SignalHandler( int signum )
{
    if( signum == SIGINT )
        g_bExit = true;
    else if( signum == SIGUSR1 )
        OutputMsg( 0,
            "remote connection is down" );
}

std::atomic< guint32 > g_arrInterVals[4]=
    { {10}, {10}, {10}, {10} };

std::atomic< guint32 >& g_dwInterval = g_arrInterVals[ 0 ];
std::string g_arrSchedule[ 4 ] =
    { "", "", "", "" };
std::string& g_strSchedule = g_arrSchedule[ 0 ];
CronSchedule g_arrCronSched[ 4 ];
TaskletPtr g_arrTimers[ 4 ];

stdrmutex g_oTimerLock;

stdrmutex& GetTmLock()
{ return g_oTimerLock; }

struct CAsyncTimerCallbacks : public CAsyncStdAMCallbacks
{
    typedef CAsyncStdAMCallbacks super;

    gint32 GetPointValuesToUpdate(
        InterfPtr& pIf,
        std::vector< KeyValue >& veckv ) override
   {
        gint32 ret = 0;
        KeyValue okv;
        okv.strKey = O_PID;
        okv.oValue = ( guint32 )getpid();
        veckv.push_back( okv );

        okv.strKey = O_OBJ_COUNT;
        okv.oValue = ( guint32 )
            CObjBase::GetActCount();
        veckv.push_back( okv );
        return ret;
   }

    gint32 SetPointValuesCallback( 
        IConfigDb* context, gint32 iRet )
    {
        if( context == nullptr )
            return 0;
        if( SUCCEEDED( iRet ) )
            return 0;

        gint32 ret = 0;
        do{
            InterfPtr pProxy;
            ret = GetAppManagercli( pProxy );
            if( ERROR( ret ) )
                break;
            CAppManager_CliImpl* pam = pProxy;
            CCfgOpener oCtx( context );
            stdstr strApp;
            ret = oCtx.GetStrProp(
                propObjName, strApp );
            if( ERROR( ret ) )
                break;
            if( ERROR( iRet ) )
            {
                LOGWARN( pam->GetIoMgr(), iRet,
                "Warning, failed to update '%s' "
                "offline counters",
                strApp.c_str() );
            }
        }while( 0 );
        return 0;
    }


    void CalOfflineCounters( 
        const std::vector< KeyValue >& arrKvs,
        std::vector< KeyValue >& vecKvs )
    {
        Variant rxb( ( guint64 )0 );
        Variant txb( ( guint64 )0 );
        Variant offl( ( guint32 )0 );
        Variant uptime( ( guint32 )0 );
        for( auto& elem : arrKvs )
        {
            if( elem.strKey == "rx_bytes" ||
                elem.strKey == "rx_bytes_total" )
            {
                ( ( guint64& )rxb ) += ( guint64& )elem.oValue;
                DebugPrint( 0, "rxb = %lx", ( guint64& )rxb );
            }
            else if( elem.strKey == "tx_bytes" ||
                elem.strKey == "tx_bytes_total" )
            {
                ( ( guint64& )txb ) += ( guint64& )elem.oValue;
                DebugPrint( 0, "txb = %lx", ( guint64& )txb );
            }
            else if( elem.strKey == "uptime_total" ||
                elem.strKey == "uptime" )
            {
                ( ( guint32& )uptime ) += ( guint32& )elem.oValue;
                DebugPrint( 0, "uptime = %x", ( guint32& )uptime );
            }
            else if( elem.strKey == "offline_times" )
            {
                ( ( guint32& )offl ) += ( guint32& )elem.oValue + 1;
                DebugPrint( 0, "offline_times = %x", ( guint32& )uptime );
            }
        }
        KeyValue okv;
        okv.strKey = "rx_bytes_total";
        okv.oValue = rxb;
        vecKvs.emplace_back( okv );
        okv.strKey = "tx_bytes_total";
        okv.oValue = txb;
        vecKvs.emplace_back( okv );
        okv.strKey = "offline_times";
        okv.oValue = offl;
        vecKvs.emplace_back( okv );
        okv.strKey = "uptime_total";
        okv.oValue = uptime;
        vecKvs.emplace_back( okv );
    }

    gint32 GetPointValuesCallback(
        IConfigDb* context, gint32 iRet,
        std::vector<KeyValue>& arrKeyVals /*[ In ]*/ )
    {
        if( ERROR( iRet ) )
            return iRet;
        gint32 ret = 0;
        do{
            InterfPtr pProxy;
            ret = GetAppManagercli( pProxy );
            if( ERROR( ret ) )
                break;
            CAppManager_CliImpl* pam = pProxy;

            std::vector< KeyValue > vecKvs;
            CalOfflineCounters(
                arrKeyVals, vecKvs );
            if( vecKvs.empty() )
                break;

            stdstr strApp;
            CCfgOpener oCtx( context );
            ret = oCtx.GetStrProp(
                propObjName, strApp );
            if( ERROR( ret ) )
                break;

            ret = pam->SetPointValues(
                context, strApp, vecKvs );
        }while( 0 );
        return ret;
    }


    gint32 UpdateOfflineCounters(
        const stdstr& strApp )
    {
        if( strApp.empty() )
            return -EINVAL;
        gint32 ret = 0;
        do{
            InterfPtr pProxy;
            ret = GetAppManagercli( pProxy );
            if( ERROR( ret ) )
                break;
            CAppManager_CliImpl* pam = pProxy;

            std::vector< stdstr > vecPoints = {
                "rx_bytes",
                "rx_bytes_total",
                "tx_bytes",
                "tx_bytes_total",
                "uptime",
                "uptime_total",
                "offline_times" };
            std::vector< KeyValue > arrKvs, newKvs;
            CCfgOpener oContext;
            oContext.SetStrProp( propObjName, strApp );
            ret = pam->GetPointValues(
                oContext.GetCfg(),
                strApp, vecPoints, arrKvs );
            if( ret == STATUS_PENDING )
                break;
            if( ERROR( ret ) )
                break;

            if( arrKvs.empty() )
            {
                ret = -ENOENT;
                break;
            }

            CalOfflineCounters( arrKvs, newKvs );
            if( newKvs.empty() )
            {
                ret = -ENOENT;
                break;
            }
            ret = pam->SetPointValues(
                oContext.GetCfg(),
                strApp, newKvs );

        }while( 0 );
        return ret;
    }
    //RPC event handler 'OnPointChanged'
    gint32 OnPointChanged(
        IConfigDb* context, 
        const std::string& strPtPath /*[ In ]*/,
        const Variant& value /*[ In ]*/ ) override
    {
        do{
            if( strPtPath ==
                g_strAppInst + "/interval1" )
            {
                guint32 dwWaitSec = value;
                if( dwWaitSec> 86400 )
                    break;

                g_dwInterval = dwWaitSec;
                OutputMsg( 0,
                    "interval changed to %d",
                    dwWaitSec );
            }
            else if( strPtPath ==
                g_strAppInst + "/interval2" )
            {
                guint32 dwWaitSec = value;
                if( dwWaitSec > 86400 )
                    break;

                g_arrInterVals[ 1 ] = dwWaitSec;
                DebugPrint( 0,
                    "interval2 changed to %d",
                    dwWaitSec );
            }
            else if( strPtPath ==
                g_strAppInst + "/interval3" )
            {
                guint32 dwWaitSec = value;
                if( dwWaitSec > 86400 )
                    break;

                g_arrInterVals[ 2 ] = dwWaitSec;
                DebugPrint( 0,
                    "interval3 changed to %d",
                    dwWaitSec );
            }
            else if( strPtPath ==
                g_strAppInst + "/interval4" )
            {
                guint32 dwWaitSec = value;
                if( dwWaitSec > 86400 )
                    break;

                g_arrInterVals[ 3 ] = dwWaitSec;
                DebugPrint( 0,
                    "interval3 changed to %d",
                    dwWaitSec );
            }
            else if( strPtPath ==
                g_strAppInst + "/schedule1" )
            {
                CStdRMutex oTimerLock( GetTmLock() );
                g_strSchedule.clear();
                BufPtr& pBuf = ( BufPtr& )value;
                g_strSchedule.append(
                    pBuf->ptr(), pBuf->size() );
                DebugPrint( 0,
                    "schedule1 changed to %d",
                    g_strSchedule );
                std::time_t t = std::time(nullptr);
                std::tm now = *std::localtime(&t);
                try{
                    g_arrCronSched[ 0 ] =
                        ParseCron(g_strSchedule, now);
                }
                catch( std::runtime_error& e )
                {
                    DebugPrint( 0,
                        "%s in cron expression: %s",
                        e.what(),
                        g_strSchedule.c_str() );
                }
            }
            else if( strPtPath ==
                g_strAppInst + "/offline_action" )
            {
                UpdateOfflineCounters( value );
            }
            else
            {
                super::OnPointChanged(
                    context, strPtPath, value );
            }
            break;
        }while( 0 );
        return 0;
    }

    gint32 ClaimAppInstCallback(
        IConfigDb* context, gint32 iRet,
        std::vector<KeyValue>& arrPtToGet /*[ In ]*/ ) override
    {
        gint32 ret = 0;
        bool bFirst = false;
        {
            CStdRMutex oLock( GetTmLock() );
            if( g_strSchedule.empty() )
                bFirst = true;
        }
        do{
            if( ERROR( iRet ) )
            {
                ret = iRet;
                break;
            }
            for( auto& kv : arrPtToGet )
            {
                if( kv.strKey == "interval1" )
                {
                    guint32 dwInterval = kv.oValue;
                    if( dwInterval > 86400 )
                        continue;
                    g_dwInterval = dwInterval;
                }
                else if( kv.strKey == "interval2" )
                {
                    g_arrInterVals[ 1 ] = kv.oValue;
                }
                else if( kv.strKey == "schedule1" )
                {
                    BufPtr pBuf = ( BufPtr& )kv.oValue;
                    if( pBuf.IsEmpty() || pBuf->empty() )
                        continue;
                    CStdRMutex oLock( GetTmLock() );
                    g_strSchedule.clear();
                    g_strSchedule.append(
                        pBuf->ptr(), pBuf->size() );

                    std::time_t t = std::time(nullptr);
                    std::tm now = *std::localtime(&t);
                    try{
                        g_arrCronSched[ 0 ] =
                            ParseCron(g_strSchedule, now);
                    }
                    catch( std::runtime_error& e )
                    {
                        DebugPrint( 0,
                            "%s in cron expression: %s",
                            e.what(),
                            g_strSchedule.c_str() );
                    }
                }
            }

        }while( 0 );
        if( !g_pSyncTask.IsEmpty() && bFirst )
        {
            g_pSyncTask->SetError( ret );
            ( *g_pSyncTask )( eventTaskComp );
        }
        return ret;
    }
};

gint32 InitContext()
{
    gint32 ret = CoInitialize( 0 );
    if( ERROR( ret ) )
        return ret;
    do{
        CParamList oParams;
        oParams.Push( "appmonsvr" );
        oParams[ propSearchLocal ] = false;
        oParams[ propEnableLogging ] = g_bLogging;

        // adjust the thread number if necessary
        oParams[ propMaxIrpThrd ] = 0;
        oParams[ propMaxTaskThrd ] = 4;
        
        ret = g_pIoMgr.NewObj(
            clsid( CIoManager ), 
            oParams.GetCfg() );
        if( ERROR( ret ) )
            break;

        CIoManager* pSvc = g_pIoMgr;
        ret = pSvc->Start();
        if( ERROR( ret ) )
            break;
    }while( 0 );

    return ret;
}

gint32 DestroyContext()
{
    IService* pSvc = g_pIoMgr;
    if( pSvc != nullptr )
    {
        pSvc->Stop();
        g_pIoMgr.Clear();
    }

    CoUninitialize();
    DebugPrintEx( logErr, 0,
        "#Leaked objects is %d",
        CObjBase::GetActCount() );
    return STATUS_SUCCESS;
}

static void Usage( const char* szName )
{
    fprintf( stderr,
        "Usage: %s [OPTIONS]\n"
        "\t [ -d to run as a daemon ]\n"
        "\t [ -n <appinst name> specify an alternative apptimer instance, default 'timer1' ]\n"
        "\t [ -g send logs to log server ]\n"
        "\t [ -h this help ]\n", szName );
}

gint32 TimerLoop();

int main( int argc, char** argv )
{
    gint32 ret = 0;
    do{
        bool bDaemon = false;
        int opt = 0;
        while( ( opt = getopt( argc, argv, "hdgn:" ) ) != -1 )
        {
            switch( opt )
            {
                case 'd':
                    { bDaemon = true; break; }
                case 'g':
                    { g_bLogging = true; break; }
                case 'n':
                    {
                        g_strAppInst = optarg;
                        if( !IsValidName( g_strAppInst ) )
                        {
                            printf( "Error, bad app instance name" );
                            ret = -EINVAL;
                        }
                        break;
                    }
                case 'h':
                default:
                    { Usage( argv[ 0 ] ); exit( 0 ); }
            }
        }
        if( ERROR( ret ) )
            break;

        if( bDaemon )
        {
            ret = daemon( 1, 0 );
            if( ret < 0 )
            { ret = -errno; break; }
        }

        ret = InitContext();
        if( ERROR( ret ) )
            break;
        
        CIoManager* pMgr = g_pIoMgr;
        ret = pMgr->TryLoadClassFactory(
            "libappmancli.so" );
        if( ERROR( ret ) )
            break;

        ret = g_pSyncTask.NewObj(
            clsid( CSyncCallback ) );
        if( ERROR( ret ) )
            break;

        stdstr strCmdLine(
            SimpleCmdLine( argc, argv ) );
        pMgr->SetCmdLineOpt(
            propCmdLine, strCmdLine );

        InterfPtr pIf;
        PACBS pacbsIn( new CAsyncTimerCallbacks );
        InterfPtr pAppMan;
        // the pIf is just a placeholder, not for real.
        pIf = pMgr->GetSyncIf();
        ret = StartStdAppManCli(
            pIf, g_strAppInst, pAppMan, pacbsIn );
        if( ERROR( ret ) )
            break;
        
        if( SUCCEEDED( ret ) )
            ret = TimerLoop();
            
        StopStdAppManCli();
    }while( 0 );

    if( !g_pSyncTask.IsEmpty() )
    {
        ( *g_pSyncTask )( eventCancelTask );
        g_pSyncTask.Clear();
    }
    DestroyContext();
    return ret;
}

// Function to wait for a specified number of seconds
// (supports fractional seconds)
void WaitForSeconds(double seconds)
{
    struct timeval tv;
    // Extract integer part of seconds
    tv.tv_sec = static_cast<int>(seconds);
    // Extract fractional part of seconds
    tv.tv_usec = static_cast<int>((seconds - tv.tv_sec) * 1e6);
    select(0, nullptr, nullptr, nullptr, &tv);
}

inline bool IsValidInterval(
    guint32 dwInterval )
{
    if( dwInterval == 0 || dwInterval > 86400 )
        return false;
    return true;
}

gint32 TimerFunc( guint8 idx )
{
    gint32 ret = 0;
    do{
        if( idx < 1 || idx > 3 )
            return -EINVAL;
        InterfPtr pProxy;
        ret = GetAppManagercli( pProxy );
        if( ERROR( ret ) )
            break;
        CAppManager_CliImpl* pam = pProxy;
        stdstr strPtName = g_strAppInst + "/clock";
        strPtName.append( 1, ( char )idx );
        CCfgOpener oCfg;
        oCfg.SetIntProp( propContext, 2 );
        Variant var( ( guint32 )1);
        pam->SetPointValue( oCfg.GetCfg(),
            strPtName, var );
    }while( 0 );

    TaskletPtr pTask; 
    CStdRMutex oLock( GetTmLock() );
    guint32 dwInterval = g_arrInterVals[ idx ];
    if( !IsValidInterval( dwInterval ) )
        dwInterval = 10;
    ret = ADD_TIMER_FUNC( pTask,
        dwInterval, g_pIoMgr, TimerFunc, idx );
    if( SUCCEEDED( ret ) )
        g_arrTimers[ idx ] = pTask;
    return ret;
}

gint32 AddTimerForPointX( char idx )
{
    gint32 ret = 0;
    do{
        if( idx < 1 || idx > 3 )
            return -EINVAL;
        CStdRMutex oLock( GetTmLock() );
        TaskletPtr pTask;
        guint32 dwInterval = g_arrInterVals[ idx ];
        if( !IsValidInterval( dwInterval ) )
            dwInterval = 10;
        ret = ADD_TIMER_FUNC( pTask,
            dwInterval, g_pIoMgr,
            TimerFunc, ( guint8 )idx );
        if( ERROR( ret ) )
            break;
        g_arrTimers[ idx ] = pTask;
    }while( 0 );
    return ret;
}

gint32 CancelTimerPointX( char idx )
{
    gint32 ret = 0;
    do{
        if( idx < 1 || idx > 3 )
            return -EINVAL;
        CStdRMutex oLock( GetTmLock() );
        TaskletPtr pTask = g_arrTimers[ idx ];
        if( pTask.IsEmpty() )
            break;
        g_arrTimers[ idx ].Clear();
        oLock.Unlock();
        ( *pTask )( eventCancelTask );
    }while( 0 );
    return ret;
}
//-----Your code begins here---
gint32 TimerLoop()
{
    gint32 ret = 0;
    auto iOldSig = 
        signal( SIGINT, SignalHandler );
    signal( SIGUSR1, SignalHandler );

    guint32 dwTicks = 0;

    if( !g_pSyncTask.IsEmpty() )
    {
        CSyncCallback* pSync = g_pSyncTask;
        pSync->WaitForComplete();
        ret = pSync->GetError();
        if( ERROR( ret ) )
        {
            OutputMsg( ret, "Error in ClaimAppInstCallback" );
            return ret;
        }
    }

    for( int i = 1; i < 2; i++ )
        AddTimerForPointX( i );

    while( !g_bExit )
    {
        dwTicks++;
        InterfPtr pProxy;
        ret = GetAppManagercli( pProxy );
        if( ERROR( ret ) )
        {
            ret = 0;
            WaitForSeconds( 1 );
            continue;
        }
        CAppManager_CliImpl* pam = pProxy;

        CCfgOpener oCfg;
        if( dwTicks % g_dwInterval )
        {
            WaitForSeconds( 1 );
            continue;
        }
        oCfg.SetIntProp( propContext, 2 );
        Variant var( ( guint32 )1);
        pam->SetPointValue( oCfg.GetCfg(),
            g_strAppInst + "/clock1", var );
        DebugPrint( 0,
            "Info send clock1 %d", dwTicks );

        CStdRMutex oLock( GetTmLock() );
        std::time_t t = std::time(nullptr);
        std::tm now = *std::localtime(&t);
        if( Matches( g_arrCronSched[ 0 ], now ) )
        {
            oLock.Unlock();
            pam->SetPointValue( oCfg.GetCfg(),
                g_strAppInst + "/sched_task1", var );
        }
        oLock.Unlock();
        WaitForSeconds( 1 );
    }

    ret = STATUS_SUCCESS;
    for( int i = 1; i > 0; i-- )
        CancelTimerPointX( i );

    signal( SIGINT, iOldSig );
    return ret;
}

