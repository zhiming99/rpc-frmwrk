// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2025  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ../../../../ridl/.libs/ridlc -m timer1 --server -sO . ./apptimer.ridl 
#include "rpc.h"
#include "proxy.h"
using namespace rpcf;
#include "stmport.h"
#include "fastrpc.h"
#include "AppManagercli.h"
#include "frmwrk.h"

ObjPtr g_pIoMgr;
#include <signal.h>
#include <stdlib.h>
#include <limits.h>

std::atomic< bool > g_bExit( false );
void SignalHandler( int signum )
{
    if( signum == SIGINT )
        g_bExit = true;
    else if( signum == SIGUSR1 )
        OutputMsg( 0,
            "remote connection is down" );
}

std::atomic< guint32 > g_dwInterval( 10 );

struct CAsyncTimerCallbacks : public CAsyncStdAMCallbacks
{
    typedef CAsyncStdAMCallbacks super;

    gint32 GetPointValuesToUpdate(
        InterfPtr& pIf,
        std::vector< KeyValue >& veckv ) override
   {
        gint32 ret = 0;
        KeyValue okv;
        okv.strKey = O_PID;
        okv.oValue = ( guint32 )getpid();
        veckv.push_back( okv );

        okv.strKey = O_OBJ_COUNT;
        okv.oValue = ( guint32 )
            CObjBase::GetActCount();
        veckv.push_back( okv );
        return ret;
   }

    gint32 SetPointValueCallback( 
        IConfigDb* context, gint32 iRet )
    { return 0; }

    //RPC event handler 'OnPointChanged'
    gint32 OnPointChanged(
        IConfigDb* context, 
        const std::string& strPtPath /*[ In ]*/,
        const Variant& value /*[ In ]*/ ) override
    {
        do{
            if( strPtPath != "timer1/interval1" )
            {
                super::OnPointChanged(
                    context, strPtPath, value );
                break;
            }
            guint32 dwWaitSec = value;
            if( dwWaitSec> 3600 )
                break;

            g_dwInterval = dwWaitSec;
            OutputMsg( 0,
                "interval changed to %d",
                dwWaitSec );

        }while( 0 );
        return 0;
    }

};

gint32 InitContext()
{
    gint32 ret = CoInitialize( 0 );
    if( ERROR( ret ) )
        return ret;
    do{
        CParamList oParams;
        oParams.Push( "appmonsvr" );
        oParams[ propSearchLocal ] = false;

        // adjust the thread number if necessary
        oParams[ propMaxIrpThrd ] = 0;
        oParams[ propMaxTaskThrd ] = 4;
        
        ret = g_pIoMgr.NewObj(
            clsid( CIoManager ), 
            oParams.GetCfg() );
        if( ERROR( ret ) )
            break;

        CIoManager* pSvc = g_pIoMgr;
        ret = pSvc->Start();
        if( ERROR( ret ) )
            break;
    }while( 0 );

    return ret;
}

gint32 DestroyContext()
{
    IService* pSvc = g_pIoMgr;
    if( pSvc != nullptr )
    {
        pSvc->Stop();
        g_pIoMgr.Clear();
    }

    CoUninitialize();
    DebugPrintEx( logErr, 0,
        "#Leaked objects is %d",
        CObjBase::GetActCount() );
    return STATUS_SUCCESS;
}

gint32 TimerLoop();

int main( int argc, char** argv )
{
    gint32 ret = 0;
    do{
        ret = InitContext();
        if( ERROR( ret ) )
            break;
        
        CIoManager* pMgr = g_pIoMgr;
        ret = pMgr->TryLoadClassFactory(
            "libappmancli.so" );
        if( ERROR( ret ) )
            break;
        InterfPtr pIf;

        PACBS pacbsIn( new CAsyncTimerCallbacks );
        InterfPtr pAppMan;
        pIf = pMgr->GetSyncIf();
        ret = StartStdAppManCli(
            pIf, "timer1", pAppMan, pacbsIn );
        if( ERROR( ret ) )
            break;
        
        if( SUCCEEDED( ret ) )
            ret = TimerLoop();
            
        StopStdAppManCli();
    }while( 0 );

    DestroyContext();
    return ret;
}

//-----Your code begins here---
gint32 TimerLoop()
{
    gint32 ret = 0;
    auto iOldSig = 
        signal( SIGINT, SignalHandler );
    signal( SIGUSR1, SignalHandler );

    guint32 dwTicks = 0;
    while( !g_bExit )
    {
        dwTicks++;
        InterfPtr pProxy;
        ret = GetAppManagercli( pProxy );
        if( ERROR( ret ) )
        {
            ret = 0;
            sleep( 1 );
            continue;
        }
        CAppManager_CliImpl* pam = pProxy;

        CCfgOpener oCfg;
        if( dwTicks % g_dwInterval )
        {
            sleep( 1 );
            continue;
        }
        oCfg.SetIntProp( propContext, 2 );
        Variant var( ( guint32 )1);
        pam->SetPointValue( oCfg.GetCfg(),
            "timer/clock1", var );
        OutputMsg( 0, 
            "Info send clock1 %d",
            dwTicks );

        PACBS pcbs;
        CfgPtr pContext;
        ret = pam->GetAsyncCallbacks(
            pcbs, pContext );
        if( SUCCEEDED( ret ) )
        {
            InterfPtr pEmpty;
            std::vector< KeyValue > veckv;
            pcbs->GetPointValuesToUpdate(
                pEmpty, veckv );
            if( veckv.size() )
            {
                CCfgOpener oCfg;
                pam->SetPointValues( oCfg.GetCfg(),
                    "timer1", veckv );
            }
        }

        sleep( 1 );
    }

    ret = STATUS_SUCCESS;

    signal( SIGINT, iOldSig );
    return ret;
}

