// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2025  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// /usr/local/bin/ridlc --sync_mode IAppStore=sync --sync_mode IDataProducer=sync --services=AppManager --client --pkgname=org.rpcf.appmancli -jlsO . ../../../../monitor/appmon/appmon.ridl 
package org.rpcf.appmancli;
import org.rpcf.rpcbase.*;
import java.util.Map;
import java.util.HashMap;
import java.lang.String;
import java.nio.ByteBuffer;
import java.lang.String;

import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeUnit;
import java.io.File;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.lang.Process;
import java.lang.Runtime;
import java.util.ArrayList;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.function.Consumer;
import java.util.concurrent.Callable;

import static org.rpcf.rpcbase.rpcbaseJNI.JavaOutputMsg;

public class maincli
{
    static public boolean m_bExited = false;
    static public synchronized void setExited()
    {m_bExited = true;}
    static public synchronized boolean isExited()
    {return m_bExited;}

    static public boolean m_bExit = false;
    static public synchronized void setExit()
    {m_bExit = true;}
    static public synchronized boolean isExit()
    {return m_bExit;}

    public static int m_iRetryInterval = 10;
    public static AppManagercli m_oAppMancli = null;
    public static synchronized void setAppmangercli( AppManagercli o )
    { m_oAppMancli = o; }
    public static synchronized AppManagercli getAppmangercli()
    { return m_oAppMancli ; }

    public static BlockingQueue<Consumer<AppManagercli>> m_taskQueue = new LinkedBlockingQueue<>();

    static void WaitSeconds( int seconds ) {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
        }
    }
    public static boolean addTask( Consumer<AppManagercli> o )
    { return m_taskQueue.offer(o); }

    public static String getDescPath( String strName )
    {
        String strDescPath =
            maincli.class.getProtectionDomain().getCodeSource().getLocation().getPath();
        String strDescPath2 = strDescPath + "/org/rpcf/appmancli/" + strName;
        File oFile = new File( strDescPath2 );
        if( oFile.isFile() )
            return strDescPath2;
        strDescPath += "/" + strName;
        oFile = new File( strDescPath );
        if( oFile.isFile() )
            return strDescPath;
        strDescPath = CopyResource( strName );
        return strDescPath;
    }
    // copy resource from a jar to the working directory
    public static String CopyResource( String strName )
    {
        boolean bFound = false;
        String strDestPath =
            System.getProperty( "user.dir" );
        InputStream stream = null;
        String strSrcPath = "/static/" + strName;
        boolean bSync = false;
        if( strName.equals( "driver.json" ) ||
            strName.equals( "driver-cli.json" ) )
            bSync = true;
        try{
            stream = maincli.class.getResourceAsStream( strSrcPath );
            Path dstPath = Paths.get( strDestPath + "/" + strName );
            Files.copy( stream, dstPath, StandardCopyOption.REPLACE_EXISTING );
            bFound = true;
            if( bSync )
            {
                String strSync = "/org/rpcf/appmancli/synccfg.py";
                stream = maincli.class.getResourceAsStream( strSync );
                dstPath = Paths.get( strDestPath + "/synccfg.py" );
                Files.copy( stream, dstPath, StandardCopyOption.REPLACE_EXISTING );
                String[] commands = { "python3", "./synccfg.py" };
                Process p = Runtime.getRuntime().exec(commands);
            }
        }catch ( Exception e ){
            bFound = false;
        }
        if( !bFound )
            return "";
        return strDestPath + "/" + strName;
    }
    static public int startAppManagercli(
         JavaRpcServer oTarget,
         JavaRpcContext oCtx, String strAppInst,
         Callable<AppManagercli> oCreateFunc,
         boolean bNewThread )
    {
        if( bNewThread )
        {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    AMThreadProc( oTarget, oCtx, strAppInst, oCreateFunc );
                }
            }).start();
        }
        else
        {
            return AMThreadProc( oTarget, oCtx, strAppInst, oCreateFunc);
        }
        return 0;
    }
    static public int AMThreadProc(JavaRpcServer oTarget  ,
                                   JavaRpcContext oCtx, String strAppInst,
                                   Callable<AppManagercli> oCreateFunc)
    {
        int ret = 0;
        AppManagercli oSvc = null;
        while( !isExit() ) {
            try {
                String strDescPath =
                        getDescPath("appmondesc.json");
                if (strDescPath.isEmpty()) {
                    ret = -RC.ENOENT;
                    return ret;
                }
                // create the proxy object
                if( oCreateFunc != null ) {
                    oSvc = oCreateFunc.call();
                } else {
                    oSvc = new AppManagercli(
                            oCtx.getIoMgr(),
                            strDescPath,
                            "AppManager");
                }
                setAppmangercli(oSvc);
                oSvc.m_strAppInst = strAppInst;
                oSvc.m_oTarget = oTarget;

                // check if there are errors
                if (RC.ERROR(oSvc.getError())) {
                    ret = oSvc.getError();
                    rpcbase.JavaOutputMsg(
                            "Error create AppManagercli: " + ret);
                    continue;
                }
                // start the AppManagercli
                ret = oSvc.start();
                if (RC.ERROR(ret) )
                    continue;
                if( oSvc.getState() != RC.stateConnected)
                    continue;
                ret = MainCli( oTarget, oSvc, strAppInst );
            } catch (Exception e) {
                e.printStackTrace();
                ret = -rpcbaseConstants.EFAULT;
            } finally {
                rpcbase.JavaOutputMsg(
                        "Error start AppManagercli: " + ret);
                if (oSvc != null) {
                    oSvc.stop();
                    oSvc.setInst(null);
                }
                setAppmangercli(null);
                if( !isExit() ) {
                    JavaOutputMsg("Lost connection to monitor server, reconnection is scheduled...");
                    WaitSeconds(m_iRetryInterval);
                }
            }
        }
        setExited();
        return ret;
    }

    // ------customize this method for your own purpose----
    public static int MainCli(
            JavaRpcServer oTarget,
            AppManagercli oProxy,
            String strAppInst)
    {
        ArrayList<KeyValue> arrKvs = new ArrayList<>();
        oProxy.getPointValuesToUpdate( oTarget, arrKvs);
        KeyValue okv = new KeyValue();
        okv.strKey = "pid";
        okv.oValue = new JVariant();
        okv.oValue.iType = rpcbaseConstants.typeUInt32;
        okv.oValue.val = (int)ProcessHandle.current().pid();
        arrKvs.add(okv);

        okv = new KeyValue();
        okv.strKey = "working_dir";
        okv.oValue = new JVariant();
        okv.oValue.iType = rpcbaseConstants.typeByteArr;
        okv.oValue.val = System.getProperty("user.dir")
                .getBytes(StandardCharsets.UTF_8);
        arrKvs.add(okv);

        JRetVal jRetVal = oProxy.ClaimAppInst( strAppInst,
            arrKvs.toArray( new KeyValue[0]) );
        if( jRetVal.ERROR()) {
            rpcbase.JavaOutputMsg(
                    "Error failed to ClaimAppInst " + strAppInst);
            return jRetVal.getError();
        }
        while( !isExit() )
        {
            Consumer<AppManagercli> task = null;
            try {
                task = m_taskQueue.poll(1, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                if( isExit() )
                    break;
                continue;
            }
            if( task != null ) {
                task.accept( oProxy );
            }
        }
        if( oProxy.getState() == rpcbaseConstants.stateConnected ) {
            ArrayList< String > oArrApps = new ArrayList<>();
            oArrApps.add( strAppInst );
            oProxy.FreeAppInsts( oArrApps.toArray( new String[0]));
        }
        return RC.STATUS_SUCCESS;
    }

    public static void stopAppManagercli() {
        setExit();
        while( !isExited() )
            WaitSeconds(1);
    }
}