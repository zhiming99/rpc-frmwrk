# GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
# Copyright (C) 2024  zhiming <woodhead99@gmail.com>
# This program can be distributed under the terms of the GNU GPLv3.
# ../../../../ridl/.libs/ridlc --services=AppMonitor --client -spO . ../../../../monitor/appmon/appmon.ridl 
from typing import Tuple
from rpcf.rpcbase import *
from rpcf.proxy import *
from seribase import CSerialBase
from seribase import Variant
from appmonstructs import *
import errno

from AppMonitorcli import CAppMonitorProxy
import os
import time

import signal
import random
import AppMonitorcli as am

def SigHandler( signum, frame ):
    am.bExit = True

def MainEntryCli() :
    ret = 0
    signal.signal( signal.SIGINT, SigHandler)
    oContext = PyRpcContext( 'appmoncli' )
    with oContext as ctx:
        if ctx.status < 0:
            ret = ctx.status
            print( os.getpid(), 
                "Error start PyRpcContext %d" % ret )
            return ret
        
        print( "start to work here..." )
        strPath_ = os.path.dirname( os.path.realpath( __file__) )
        strPath_ += '/appmondesc.json'
        oProxy_AppMonitor = CAppMonitorProxy( ctx.pIoMgr,
            strPath_, 'AppMonitor' )
        ret = oProxy_AppMonitor.GetError()
        if ret < 0 :
            return ret
        
        with oProxy_AppMonitor as oProxy:
            try:
                ret = oProxy.GetError()
                if ret < 0 :
                    raise Exception( 'start proxy failed' )
                state = oProxy.oInst.GetState()
                while state == cpp.stateRecovery :
                    time.sleep( 1 )
                    state = oProxy.oInst.GetState()
                    if am.bExit:
                        break
                if state != cpp.stateConnected or am.bExit:
                    return ErrorCode.ERROR_STATE
                ret = maincli( oProxy )
            except Exception as err:
                print( err )
            
        oProxy_AppMonitor = None
    oContext = None
    return ret
    
#------customize the method below for your own purpose----
def maincli( 
    oProxy: CAppMonitorProxy ) -> int:
    try:
        ret = oProxy.RegisterListener(
            ["rpcrouter1", "timer1" ] )
        if ret[0] < 0:
            raise Exception( 'RegisterListener failed' )

        ticks = 0
        newInterval = 10
        while not am.bExit :
            time.sleep( 1 )
            ticks += 1
            if ticks % 20 == 0:
                newInterval = int( ( random.random() * 255 ) % 10 + 10 )
                print( "new interval", newInterval )
                var = Variant()
                var.val = newInterval
                var.iType = cpp.typeUInt32
                ret = oProxy.SetPointValue(
                    'timer1/interval1', var )
                if ret[0] < 0:
                    raise Exception( 'SetPointValue failed %d' % ret[0] )
                else:
                    print( 'SetPointValue ok', newInterval )

    except Exception as err:
        print( err )
    finally:
        oProxy.RemoveListener()
    return 0
    
if __name__ == '__main__' :
    ret = MainEntryCli()
    quit( -ret )
