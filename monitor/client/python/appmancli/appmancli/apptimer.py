#!/usr/bin/python3
# GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
# Copyright (C) 2024  zhiming <woodhead99@gmail.com>
# This program can be distributed under the terms of the GNU GPLv3.
# ridlc --client --services AppManager --sync_mode IDataProducer=sync -psO . ./appmon.ridl 
from rpcf.rpcbase import *
from rpcf.proxy import *
from seribase import Variant

import maincli
from maincli import amc
import os
import time

import signal

bExit = False
interval = 10

def SigHandler( signum, frame ):
    global bExit
    bExit = True

class CAppTimerProxy( amc.CAppManagerProxy ):
    def __init__( self, pIoMgr, strPath, strName ):
        super().__init__( pIoMgr, strPath, strName )

    def OnPointChangedWorker(self, strPtPath, value):
        print( strPtPath, value.val )
        if strPtPath == 'timer1/interval1':
            global interval
            interval = value.val
            print( 'interval changed to', interval )
            return
        super().OnPointChangedWorker(strPtPath, value)

    def OnPointChanged( self,
        strPtPath : str,
        value : Variant
        ) :
        try:
            task = ( CAppTimerProxy.OnPointChangedWorker,
                strPtPath, value )
            amc.oTaskQue.put( task )
        except Exception as err:
            print( "Error in OnPointChanged: ", err )
        return

def StartTimer() :
    ret = 0
    oOldPath = os.getcwd()
    oPath = os.path.dirname(os.path.abspath(__file__))
    os.chdir(oPath)
    signal.signal( signal.SIGINT, SigHandler)
    oContext = PyRpcContext( 'appmoncli' )
    with oContext as ctx:
        if ctx.status < 0:
            ret = ctx.status
            print( os.getpid(), 
                "Error start PyRpcContext %d" % ret )
        try: 
            maincli.StartAppManagercli( None,
                oContext, 'timer1', 
                funcCreateProxy=lambda:
                    CAppTimerProxy( ctx.pIoMgr,
                    "invalidpath/appmondesc.json",
                    'AppManager' ) )
            while maincli.GetAppManagercli() is None:
                time.sleep( 1 )
            ret = TimerLoop()
        except Exception as err:
            print( err )
        finally:
            maincli.StopAppManagercli()
            
    oContext = None
    os.chdir(oOldPath)
    return ret
    
#------customize the method below for your own purpose----
def TimerLoop() -> int:
    '''
    adding your code here
    Calling a proxy method like
    oProxy.ListApps()
    '''
    oProxy = maincli.GetAppManagercli()
    ret = oProxy.GetPointValue(
        "timer1/interval1" )
    if ret[ 0 ] < 0:
        print( "Error failed to GetPointValue ", ret[ 0 ] )
    oVal = ret[ 1 ][ 0 ]
    global interval
    interval = oVal.val
    if interval > 10000:
        print( "Error bad interval ",
            str( interval ) )
        interval = 30
    global bExit
    dwTicks = 0
    while not bExit: 
        time.sleep( 1 )
        dwTicks += 1
        if ( dwTicks % interval ) > 0:
            continue
        value = Variant()
        value.iType = cpp.typeUInt32
        value.val = 1
        try:
            oTask = ( CAppTimerProxy.SetPointValue,
                "timer1/clock1", value )
            amc.oTaskQue.put( oTask )
            print( f"Info send clock1 {dwTicks}" )
        except Exception as err:
            print( f"Error in SetPointValue {err}" )
            continue
        finally:    
            if maincli.IsExit():
                print( "Received exit request from appmonsvr")
                break

    return ret[ 0 ] 
    
if __name__ == '__main__' :
    ret = StartTimer()
    quit( -ret )

