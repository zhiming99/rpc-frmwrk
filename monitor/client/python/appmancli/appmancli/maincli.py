# GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
# Copyright (C) 2025  zhiming <woodhead99@gmail.com>
# This program can be distributed under the terms of the GNU GPLv3.
# ridlc --services=AppManager --sync_mode IDataProducer=sync --sync_mode IAppStore=sync --client -pslO . ../../../../monitor/appmon/appmon.ridl 
from typing import Tuple
from rpcf.rpcbase import *
from rpcf.proxy import *
from seribase import CSerialBase
from seribase import Variant
from appmonstructs import *
import sys

import AppManagercli as amc
import os
import time
import threading
import queue

retryInterval = 10
bExited = False
oAppManagercli = None

def IsExit() -> bool:
    return amc.bExit

def GetAppManagercli() -> amc.CAppManagerProxy:
    """
    Returns the AppManager proxy instance.

    Returns:
        amc.CAppManagerProxy: The AppManager proxy instance.
    """
    return oAppManagercli

def StartAppManagercli( oTarget : PyRpcServer,
    oCtx: PyRpcContext, strAppInst: str,
    funcCreateProxy : callable = None,
    bNewThread : bool = True,
    strAltDesc : str = None ) -> int:
    """
    oTarget: is the target server object to monitor

    funcCreateProxy: is a callable function
    that returns a new instance of the proxy inherited from CAppManagerProxy

    strAppInst: is the application instance name, as has been created in the application registry
    """
    if bNewThread:
        threading.Thread(
            target=AMThreadProc,
            args=( oTarget, oCtx, strAppInst, funcCreateProxy, strAltDesc ),
            name='AppManagercli' ).start()
    else:
        ret = AMThreadProc( oTarget,
            oCtx, strAppInst, funcCreateProxy, strAltDesc )
        if ret < 0:
            print( "Error in AppManagercli thread" )
            return ret
    return 0

def StopAppManagercli() -> int:
    """
    Stops the AppManager client gracefully.

    Returns:
        int: Always returns 0 to indicate successful termination.
    """
    amc.bExit = True
    while not bExited:
        time.sleep( 1 )
    return 0

def AMThreadProc( oTarget : PyRpcServer,
        oCtx: PyRpcContext, strAppInst: str,
        funcCreateProxy : callable = None,
        strAltDesc : str = None ) -> int:
    ret = 0
    while not amc.bExit:
        print( "start AppManangecli..." )
        # using a fake path to force using system default config
        if strAltDesc is None:
            strPath_ = 'invalidpath/appmondesc.json'
        else:
            strPath_ = strAltDesc

        if funcCreateProxy is None:
            oProxy_AppManager = amc.CAppManagerProxy( oCtx.pIoMgr,
                strPath_, 'AppManager' )
        else:
            oProxy_AppManager = funcCreateProxy() 

        ret = oProxy_AppManager.GetError()
        if ret < 0 :
            print( "monitor server is not online, reconnect scheduled..." )
            time.sleep( retryInterval )
            continue

        amc.oTaskQue.queue.clear()
        oProxy = oProxy_AppManager
        oProxy.m_oTarget = oTarget
        oProxy.m_strAppInst = strAppInst
        global oAppManagercli
        oAppManagercli = oProxy

        try:
            oProxy.__enter__()
            ret = oProxy.GetError()
            if ret < 0 :
                raise Exception( 'start proxy failed' )
            state = oProxy.oInst.GetState()
            if state != cpp.stateConnected:
                continue
            ret = maincli( oProxy, strAppInst )
        except Exception as err:
            print( err )
        finally:
            oAppManagercli = None
            oProxy.__doexit__()
            oProxy = None
            if amc.bExit:
                break

        print( f"Connection is lost to the monitor server, reconnect in {retryInterval} seconds..." )
        time.sleep( retryInterval )
    global bExited
    bExited = True    
    return ret
    
#------customize the method below for your own purpose----
def maincli( 
    oProxy: amc.CAppManagerProxy,
    strAppInst : str ) -> int:

    arrKvs = []

    oProxy.GetPointValuesToUpdate(
        oProxy.m_oTarget, arrKvs )

    kvPid = KeyValue()
    kvPid.strKey = 'pid'
    kvPid.oValue = Variant()
    kvPid.oValue.iType = cpp.typeUInt32
    kvPid.oValue.val = os.getpid()
    arrKvs.append( kvPid )

    workdir = KeyValue()
    workdir.strKey = 'working_dir'
    workdir.oValue = Variant()
    workdir.oValue.iType = cpp.typeByteArr
    workdir.oValue.val = os.getcwd().encode()
    arrKvs.append( workdir )

    ret = oProxy.ClaimAppInst( strAppInst, arrKvs )
    if ret[ 0 ] < 0:
        print( "Error failed to ClaimAppInst ", ret[ 0 ] )
        return ret[ 0 ]

    print( f"Successfully claimed {strAppInst}" )

    cmdLine = "python3"
    for i in sys.argv:
        cmdLine += ' ' + i

    buf = cmdLine.encode()
    ret = oProxy.SetLargePointValue(
        strAppInst + '/cmdline', buf )
    if ret[ 0 ] < 0:
        return ret[ 0 ]

    while not amc.bExit:
        try:
            task = amc.oTaskQue.get(timeout=1)
            if isinstance( task, tuple ):
                func, strPtPath, value = task
                func( oProxy, strPtPath, value )
        except queue.Empty:
            pass
        if cpp.stateConnected != oProxy.oInst.GetState():
            break

    if oProxy.oInst.GetState() == cpp.stateConnected:
        oProxy.FreeAppInsts( [ strAppInst, ] )
    return ret[ 0 ] 
