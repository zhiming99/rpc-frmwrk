# GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
# Copyright (C) 2025  zhiming <woodhead99@gmail.com>
# This program can be distributed under the terms of the GNU GPLv3.
# ridlc --services=AppManager --sync_mode IDataProducer=sync --sync_mode IAppStore=sync --client -pslO . ../../../../monitor/appmon/appmon.ridl 
from typing import Tuple
from rpcf.rpcbase import *
from rpcf.proxy import *
from seribase import CSerialBase
from seribase import Variant
from appmonstructs import *
import sys

import AppManagercli as amc
import os
import time
import threading

retryInterval = 10

def StartAppManagercli( oTarget : PyRpcServer,
    oCtx: PyRpcContext, strAppInst: str ) -> int:
    threading.Thread(
        target=AMThreadProc,
        args=( oTarget, oCtx, strAppInst ),
        name='AppManagercli' ).start()
    return 0

def AMThreadProc( oTarget : PyRpcServer,
        oCtx: PyRpcContext, strAppInst: str ) -> int:
    ret = 0
    while not amc.bExit:
        print( "start AppManangecli..." )
        # using a fake path to force using system default config
        strPath_ += 'invalidpath/appmondesc.json'
        oProxy_AppManager = amc.CAppManagerProxy( oCtx.pIoMgr,
            strPath_, 'AppManager' )
        ret = oProxy_AppManager.GetError()
        if ret < 0 :
            print( "monitor server is not online, reconnect scheduled..." )
            time.sleep( retryInterval )
            continue
        
        oProxy = oProxy_AppManager
        oProxy.m_oTarget = oTarget
        oProxy.m_strAppInst = strAppInst
        try:
            oProxy.__enter__()
            ret = oProxy.GetError()
            if ret < 0 :
                raise Exception( 'start proxy failed' )
            state = oProxy.oInst.GetState()
            if amc.bExit:
                break
            if state != cpp.stateConnected:
                continue
            ret = maincli( oProxy, strAppInst )
        except Exception as err:
            print( err )
        finally:
            oProxy.__exit__()

        print( f"Connection is lost to the monitor server, reconnect in {retryInterval} seconds..." )
        time.sleep( retryInterval )
        
    return ret
    
#------customize the method below for your own purpose----
def maincli( 
    oProxy: amc.CAppManagerProxy,
    strAppInst : str ) -> int:

    arrKvs = []

    amc.GetPointValuesToUpdate( oProxy.m_oTarget, arrKvs )

    kvPid = KeyValue()
    kvPid.strKey = 'pid'
    kvPid.oValue = Variant()
    kvPid.oValue.iType = cpp.typeUInt32
    kvPid.oValue.val = os.getpid()
    arrKvs.append( kvPid )

    workdir = KeyValue()
    workdir.strKey = 'working_dir'
    workdir.oValue = Variant()
    workdir.oValue.iType = cpp.typeByteArr
    workdir.oValue.val = os.getcwd().encode()
    arrKvs.append( workdir )

    cmdLine = str()
    for i in sys.argv:
        cmdLine += i + ' '

    if len( cmdLine ) < 95:
        kvCmdLine = KeyValue()
        kvCmdLine.strKey = 'cmdline'
        kvCmdLine.oValue = Variant()
        kvCmdLine.oValue.iType = cpp.typeString
        kvCmdLine.oValue.val = cmdLine
        arrKvs.append( kvCmdLine )

    ret = oProxy.ClaimAppInst( strAppInst, arrKvs )
    if ret[ 0 ] < 0:
        print( "Error failed to ClaimAppInst ", ret[ 0 ] )
        return ret[ 0 ]

    if len( cmdLine ) >= 95:
        buf = cmdLine.encode()
        ret = oProxy.SetLargePointValue(
            strAppInst + '/cmdline', buf )
        if ret[ 0 ] < 0:
            return ret[ 0 ]

    while not amc.bExit:
        time.sleep( 1 )
        if cpp.stateConnected != oProxy.oInst.GetState():
            break

    if oProxy.oInst.GetState() == cpp.stateConnected:
        oProxy.FreeAppInsts( [ strAppInst, ] )
    return ret[ 0 ] 
