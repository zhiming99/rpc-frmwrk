# GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
# Copyright (C) 2024  zhiming <woodhead99@gmail.com>
# This program can be distributed under the terms of the GNU GPLv3.
# ridlc --client --services AppManager --sync_mode IDataProducer=sync -psO . ./appmon.ridl 
from typing import Tuple
from rpcf.rpcbase import *
from rpcf.proxy import *
from seribase import CSerialBase
from seribase import Variant
from appmonstructs import *
import errno

from AppManagercli import CAppManagerProxy
import os
import time
import sys

import signal
import AppManagercli as am
bExit = False
def SigHandler( signum, frame ):
    global bExit
    bExit = True


def MainEntryCli() :
    ret = 0
    signal.signal( signal.SIGINT, SigHandler)
    oContext = PyRpcContext( 'appmoncli' )
    with oContext as ctx:
        if ctx.status < 0:
            ret = ctx.status
            print( os.getpid(), 
                "Error start PyRpcContext %d" % ret )
            return ret
        
        print( "start to work here..." )
        strPath_ = os.path.dirname( os.path.realpath( __file__) )
        strPath_ += '/appmondesc.json'
        oProxy_AppManager = CAppManagerProxy( ctx.pIoMgr,
            strPath_, 'AppManager' )
        ret = oProxy_AppManager.GetError()
        if ret < 0 :
            return ret
        
        with oProxy_AppManager as oProxy:
            global bExit
            try:
                ret = oProxy.GetError()
                if ret < 0 :
                    raise Exception( 'start proxy failed' )
                state = oProxy.oInst.GetState()
                while state == cpp.stateRecovery :
                    time.sleep( 1 )
                    state = oProxy.oInst.GetState()
                    if bExit:
                        break
                if state != cpp.stateConnected or bExit:
                    return ErrorCode.ERROR_STATE
                ret = maincli( oProxy )
            except Exception as err:
                print( err )
            
        oProxy_AppManager = None
    oContext = None
    return ret
    
#------customize the method below for your own purpose----
def maincli( 
    oProxy: CAppManagerProxy ) -> int:
    '''
    adding your code here
    Calling a proxy method like
    oProxy.ListApps()
    '''
    kvPid = KeyValue()
    kvPid.strKey = 'pid'
    kvPid.oValue = Variant()
    kvPid.oValue.iType = cpp.typeUInt32
    kvPid.oValue.val = os.getpid()

    ret = oProxy.ClaimAppInst( "timer1", [ kvPid, ] )
    if ret[ 0 ] < 0:
        print( "Error failed to ClaimAppInst ", ret[ 0 ] )
        return ret[ 0 ]

    cmdLine = str()
    for i in sys.argv:
        cmdLine += i + ' '
    buf = cmdLine.encode()
    ret = oProxy.SetLargePointValue(
        'timer1/cmdline', buf )
    if ret[ 0 ] < 0:
        return ret[ 0 ]

    ret = oProxy.GetPointValue(
        "timer1/interval1" )
    if ret[ 0 ] < 0:
        print( "Error failed to GetPointValue ", ret[ 0 ] )
    oVal = ret[ 1 ][ 0 ]
    am.interval = oVal.val
    if am.interval > 10000:
        print( "Error bad interval ",
            str( am.interval ) )
        am.interval = 30
    global bExit
    dwTicks = 0
    while not bExit: 
        time.sleep( 1 )
        dwTicks += 1
        if ( dwTicks % am.interval ) > 0:
            continue
        value = Variant()
        value.iType = cpp.typeUInt32
        value.val = 1
        ret = oProxy.SetPointValue(
            "timer1/clock1", value )
        if ret[ 0 ] < 0 :
            print( "Error setpoint value" )
            break
        print( "Info send clock1", str( dwTicks ) )
    state = oProxy.oInst.GetState()
    if state == cpp.stateConnected:
        oProxy.FreeAppInsts( [ "timer1", ] )
    return ret[ 0 ] 
    
if __name__ == '__main__' :
    ret = MainEntryCli()
    quit( -ret )
