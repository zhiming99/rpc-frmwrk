// Generated by ridlc
// ridlc -sO . ./appmon.ridl 
// This file content could be rewritten by ridlc
#include "rpc.h"
#include "iftasks.h"
using namespace rpcf;
#include "stmport.h"
#include "fastrpc.h"
#include "appmon.h"

#include "AppMonitorcli.h"
#include "AppMonitorsvr.h"

gint32 TimeSpec::Serialize( BufPtr& pBuf_ )
{
    if( pBuf_.IsEmpty() )
        return -EINVAL;
    gint32 ret = 0;
    do{
        ret = CSerialBase::Serialize(
            pBuf_, ( ( guint32 )0x73747275 ) );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, m_dwMsgId );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, tv_sec );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, tv_nsec );
        if( ERROR( ret ) ) break;
        
    }while( 0 );

    return ret;
    
}

gint32 TimeSpec::Serialize( CBuffer& oBuf_ ) const
{
    BufPtr pBuf( &oBuf_ );
    auto pThis = const_cast< TimeSpec* >( this );
    guint32 dwOff = oBuf_.offset();
    gint32 ret = pThis->Serialize( pBuf );
    if( ERROR( ret ) ) return ret;
    oBuf_.SetOffset( dwOff );
    return 0;
    
}

gint32 TimeSpec::Deserialize( BufPtr& pBuf_ )
{
    if( pBuf_.IsEmpty() )
        return -EINVAL;
    gint32 ret = 0;
    do{
        guint32 dwMagic;
        ret = CSerialBase::Deserialize(
            pBuf_, dwMagic );
        if( ERROR( ret ) ) break;
        if( dwMagic != ( ( guint32 )0x73747275 ) )
        {
            ret = -EBADMSG;
            break;
        }
        guint32 dwMsgId = 0;
        ret = CSerialBase::Deserialize(
            pBuf_, dwMsgId );
        if( ERROR( ret ) ) break;
        if( m_dwMsgId != dwMsgId )
        {
            ret = -EBADMSG;
            break;
        }
        ret = CSerialBase::Deserialize(
            pBuf_, tv_sec );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, tv_nsec );
        
        if( ERROR( ret ) ) break;
        
    }while( 0 );

    return ret;
    
}

gint32 TimeSpec::Deserialize( const CBuffer& oBuf_ )
{
    BufPtr pBuf( const_cast< CBuffer* >( &oBuf_ ) );
    return this->Deserialize( pBuf );
}

TimeSpec& TimeSpec::operator=(
    const TimeSpec& rhs )
{
    do{
        // data members
        if( GetObjId() == rhs.GetObjId() )
            break;
        
        tv_sec = rhs.tv_sec;
        tv_nsec = rhs.tv_nsec;
        
    }while( 0 );

    return *this;
}

gint32 FileStat::Serialize( BufPtr& pBuf_ )
{
    if( pBuf_.IsEmpty() )
        return -EINVAL;
    gint32 ret = 0;
    do{
        ret = CSerialBase::Serialize(
            pBuf_, ( ( guint32 )0x73747275 ) );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, m_dwMsgId );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_dev );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_ino );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_mode );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_nlink );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_uid );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_gid );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_rdev );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_size );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_blksize );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_blocks );
        if( ERROR( ret ) ) break;
        
        st_atim.SetIf( GetIf() );
        ret = SerialStruct( 
            pBuf_, st_atim );
        if( ERROR( ret ) ) break;
        
        st_mtim.SetIf( GetIf() );
        ret = SerialStruct( 
            pBuf_, st_mtim );
        if( ERROR( ret ) ) break;
        
        st_ctim.SetIf( GetIf() );
        ret = SerialStruct( 
            pBuf_, st_ctim );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, st_name );
        if( ERROR( ret ) ) break;
        
    }while( 0 );

    return ret;
    
}

gint32 FileStat::Serialize( CBuffer& oBuf_ ) const
{
    BufPtr pBuf( &oBuf_ );
    auto pThis = const_cast< FileStat* >( this );
    guint32 dwOff = oBuf_.offset();
    gint32 ret = pThis->Serialize( pBuf );
    if( ERROR( ret ) ) return ret;
    oBuf_.SetOffset( dwOff );
    return 0;
    
}

gint32 FileStat::Deserialize( BufPtr& pBuf_ )
{
    if( pBuf_.IsEmpty() )
        return -EINVAL;
    gint32 ret = 0;
    do{
        guint32 dwMagic;
        ret = CSerialBase::Deserialize(
            pBuf_, dwMagic );
        if( ERROR( ret ) ) break;
        if( dwMagic != ( ( guint32 )0x73747275 ) )
        {
            ret = -EBADMSG;
            break;
        }
        guint32 dwMsgId = 0;
        ret = CSerialBase::Deserialize(
            pBuf_, dwMsgId );
        if( ERROR( ret ) ) break;
        if( m_dwMsgId != dwMsgId )
        {
            ret = -EBADMSG;
            break;
        }
        ret = CSerialBase::Deserialize(
            pBuf_, st_dev );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_ino );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_mode );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_nlink );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_uid );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_gid );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_rdev );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_size );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_blksize );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_blocks );
        
        if( ERROR( ret ) ) break;
        
        st_atim.SetIf( GetIf() );
        ret = DeserialStruct(
            pBuf_, st_atim );
        if( ERROR( ret ) ) break;
        
        st_mtim.SetIf( GetIf() );
        ret = DeserialStruct(
            pBuf_, st_mtim );
        if( ERROR( ret ) ) break;
        
        st_ctim.SetIf( GetIf() );
        ret = DeserialStruct(
            pBuf_, st_ctim );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, st_name );
        
        if( ERROR( ret ) ) break;
        
    }while( 0 );

    return ret;
    
}

gint32 FileStat::Deserialize( const CBuffer& oBuf_ )
{
    BufPtr pBuf( const_cast< CBuffer* >( &oBuf_ ) );
    return this->Deserialize( pBuf );
}

FileStat& FileStat::operator=(
    const FileStat& rhs )
{
    do{
        // data members
        if( GetObjId() == rhs.GetObjId() )
            break;
        
        st_dev = rhs.st_dev;
        st_ino = rhs.st_ino;
        st_mode = rhs.st_mode;
        st_nlink = rhs.st_nlink;
        st_uid = rhs.st_uid;
        st_gid = rhs.st_gid;
        st_rdev = rhs.st_rdev;
        st_size = rhs.st_size;
        st_blksize = rhs.st_blksize;
        st_blocks = rhs.st_blocks;
        st_atim = rhs.st_atim;
        st_mtim = rhs.st_mtim;
        st_ctim = rhs.st_ctim;
        st_name = rhs.st_name;
        
    }while( 0 );

    return *this;
}

gint32 IIRegFsRemote_PImpl::InitUserFuncs()
{
    BEGIN_IFPROXY_MAP( IRegFsRemote, false );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::CreateFileDummy,
        "CreateFile" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::MakeDirDummy,
        "MakeDir" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::OpenFileDummy,
        "OpenFile" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::CloseFileDummy,
        "CloseFile" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::RemoveFileDummy,
        "RemoveFile" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::ReadFileDummy,
        "ReadFile" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::WriteFileDummy,
        "WriteFile" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::TruncateDummy,
        "Truncate" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::CloseDirDummy,
        "CloseDir" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::RemoveDirDummy,
        "RemoveDir" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::SetGidDummy,
        "SetGid" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::SetUidDummy,
        "SetUid" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::GetGidDummy,
        "GetGid" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::GetUidDummy,
        "GetUid" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::SymLinkDummy,
        "SymLink" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::GetValueDummy,
        "GetValue" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::SetValueDummy,
        "SetValue" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::ChmodDummy,
        "Chmod" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::ChownDummy,
        "Chown" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::ReadLinkDummy,
        "ReadLink" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::RenameDummy,
        "Rename" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::FlushDummy,
        "Flush" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::AccessDummy,
        "Access" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::GetAttrDummy,
        "GetAttr" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::ReadDirDummy,
        "ReadDir" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::OpenDirDummy,
        "OpenDir" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIRegFsRemote_PImpl::ExecBatDummy,
        "ExecBat" );

    END_IFPROXY_MAP;
    
    return STATUS_SUCCESS;
}

gint32 IIRegFsRemote_PImpl::CreateFile(
    const std::string& strPath,
    guint32 dwMode,
    guint32 dwFlags,
    guint64& hFile )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, dwMode );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, dwFlags );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "CreateFile", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.Deserialize(
            pBuf2, hFile );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::MakeDir(
    const std::string& strPath,
    guint32 dwMode )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, dwMode );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "MakeDir", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::OpenFile(
    const std::string& strPath,
    guint32 dwFlags,
    guint64& hFile )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, dwFlags );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "OpenFile", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.Deserialize(
            pBuf2, hFile );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::CloseFile(
    guint64 hFile )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, hFile );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "CloseFile", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::RemoveFile(
    const std::string& strPath )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "RemoveFile", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::ReadFile(
    guint64 hFile,
    guint32 dwSize,
    guint32 dwOff,
    BufPtr& buffer )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, hFile );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, dwSize );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, dwOff );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "ReadFile", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.Deserialize(
            pBuf2, buffer );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::WriteFile(
    guint64 hFile,
    BufPtr& buffer,
    guint32 dwOff,
    guint32& dwSizeWrite )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, hFile );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, buffer );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, dwOff );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "WriteFile", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.Deserialize(
            pBuf2, dwSizeWrite );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::Truncate(
    guint64 hFile,
    guint32 dwOff )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, hFile );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, dwOff );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "Truncate", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::CloseDir(
    guint64 hFile )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, hFile );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "CloseDir", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::RemoveDir(
    const std::string& strPath )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "RemoveDir", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::SetGid(
    const std::string& strPath,
    guint32 wGid )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, wGid );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "SetGid", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::SetUid(
    const std::string& strPath,
    guint32 wUid )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, wUid );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "SetUid", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::GetGid(
    const std::string& strPath,
    guint32& gid )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "GetGid", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.Deserialize(
            pBuf2, gid );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::GetUid(
    const std::string& strPath,
    guint32& uid )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "GetUid", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.Deserialize(
            pBuf2, uid );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::SymLink(
    const std::string& strSrcPath,
    const std::string& strDestPath )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strSrcPath );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, strDestPath );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "SymLink", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::GetValue(
    const std::string& strPath,
    std::string& strJson )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "GetValue", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.Deserialize(
            pBuf2, strJson );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::SetValue(
    const std::string& strPath,
    const std::string& strJson )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, strJson );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "SetValue", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::Chmod(
    const std::string& strPath,
    guint32 dwMode )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, dwMode );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "Chmod", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::Chown(
    const std::string& strPath,
    guint32 dwUid,
    guint32 dwGid )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, dwUid );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, dwGid );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "Chown", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::ReadLink(
    const std::string& strPath,
    BufPtr& buf )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "ReadLink", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.Deserialize(
            pBuf2, buf );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::Rename(
    const std::string& szFrom,
    const std::string& szTo )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, szFrom );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, szTo );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "Rename", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::Flush(
    guint32 dwFlags )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, dwFlags );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "Flush", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::Access(
    const std::string& strPath,
    guint32 dwFlags )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, dwFlags );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "Access", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::GetAttr(
    const std::string& strPath,
    FileStat& oStat )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "GetAttr", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        oStat.SetIf( oDeserial_.GetIf() );
        ret = oDeserial_.DeserialStruct(
            pBuf2, oStat );
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::ReadDir(
    guint64 hDir,
    std::vector<FileStat>& vecDirEnt )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, hDir );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "ReadDir", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.DeserialArray(
            pBuf2, vecDirEnt, "(O)" );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::OpenDir(
    const std::string& strPath,
    guint32 dwFlags,
    guint64& hDir )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPath );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, dwFlags );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "OpenDir", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.Deserialize(
            pBuf2, hDir );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIRegFsRemote_PImpl::ExecBat(
    const std::string& strJson )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IRegFsRemote" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strJson );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "ExecBat", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}
gint32 IIRegFsRemote_SImpl::InitUserFuncs()
{
    BEGIN_IFHANDLER_MAP( IRegFsRemote );

    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::CreateFileWrapper,
        "CreateFile" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::MakeDirWrapper,
        "MakeDir" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::OpenFileWrapper,
        "OpenFile" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::CloseFileWrapper,
        "CloseFile" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::RemoveFileWrapper,
        "RemoveFile" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::ReadFileWrapper,
        "ReadFile" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::WriteFileWrapper,
        "WriteFile" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::TruncateWrapper,
        "Truncate" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::CloseDirWrapper,
        "CloseDir" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::RemoveDirWrapper,
        "RemoveDir" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::SetGidWrapper,
        "SetGid" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::SetUidWrapper,
        "SetUid" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::GetGidWrapper,
        "GetGid" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::GetUidWrapper,
        "GetUid" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::SymLinkWrapper,
        "SymLink" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::GetValueWrapper,
        "GetValue" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::SetValueWrapper,
        "SetValue" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::ChmodWrapper,
        "Chmod" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::ChownWrapper,
        "Chown" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::ReadLinkWrapper,
        "ReadLink" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::RenameWrapper,
        "Rename" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::FlushWrapper,
        "Flush" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::AccessWrapper,
        "Access" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::GetAttrWrapper,
        "GetAttr" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::ReadDirWrapper,
        "ReadDir" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::OpenDirWrapper,
        "OpenDir" );
    
    ADD_USER_SERVICE_HANDLER(
        IIRegFsRemote_SImpl::ExecBatWrapper,
        "ExecBat" );
    
    END_IFHANDLER_MAP;
    
    return STATUS_SUCCESS;
}

gint32 IIRegFsRemote_SImpl::CreateFileWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 dwMode;
    guint32 dwFlags;
    guint64 hFile;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwMode );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwFlags );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = CreateFile(
        strPath,
        dwMode,
        dwFlags,
        hFile );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, hFile );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::CreateFile(
    const std::string& strPath,
    guint32 dwMode,
    guint32 dwFlags,
    guint64& hFile )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->CreateFile(
        strPath,
        dwMode,
        dwFlags,
        hFile );
}

gint32 IIRegFsRemote_SImpl::MakeDirWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 dwMode;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwMode );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = MakeDir(
        strPath,
        dwMode );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::MakeDir(
    const std::string& strPath,
    guint32 dwMode )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->MakeDir(
        strPath,
        dwMode );
}

gint32 IIRegFsRemote_SImpl::OpenFileWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 dwFlags;
    guint64 hFile;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwFlags );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = OpenFile(
        strPath,
        dwFlags,
        hFile );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, hFile );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::OpenFile(
    const std::string& strPath,
    guint32 dwFlags,
    guint64& hFile )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OpenFile(
        strPath,
        dwFlags,
        hFile );
}

gint32 IIRegFsRemote_SImpl::CloseFileWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    guint64 hFile;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, hFile );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = CloseFile(
        hFile );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::CloseFile(
    guint64 hFile )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->CloseFile(
        hFile );
}

gint32 IIRegFsRemote_SImpl::RemoveFileWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = RemoveFile(
        strPath );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::RemoveFile(
    const std::string& strPath )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->RemoveFile(
        strPath );
}

gint32 IIRegFsRemote_SImpl::ReadFileWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    guint64 hFile;
    guint32 dwSize;
    guint32 dwOff;
    BufPtr buffer;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, hFile );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwSize );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwOff );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = ReadFile(
        hFile,
        dwSize,
        dwOff,
        buffer );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, buffer );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::ReadFile(
    guint64 hFile,
    guint32 dwSize,
    guint32 dwOff,
    BufPtr& buffer )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->ReadFile(
        hFile,
        dwSize,
        dwOff,
        buffer );
}

gint32 IIRegFsRemote_SImpl::WriteFileWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    guint64 hFile;
    BufPtr buffer;
    guint32 dwOff;
    guint32 dwSizeWrite;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, hFile );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, buffer );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwOff );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = WriteFile(
        hFile,
        buffer,
        dwOff,
        dwSizeWrite );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, dwSizeWrite );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::WriteFile(
    guint64 hFile,
    BufPtr& buffer,
    guint32 dwOff,
    guint32& dwSizeWrite )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->WriteFile(
        hFile,
        buffer,
        dwOff,
        dwSizeWrite );
}

gint32 IIRegFsRemote_SImpl::TruncateWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    guint64 hFile;
    guint32 dwOff;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, hFile );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwOff );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = Truncate(
        hFile,
        dwOff );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::Truncate(
    guint64 hFile,
    guint32 dwOff )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->Truncate(
        hFile,
        dwOff );
}

gint32 IIRegFsRemote_SImpl::CloseDirWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    guint64 hFile;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, hFile );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = CloseDir(
        hFile );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::CloseDir(
    guint64 hFile )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->CloseDir(
        hFile );
}

gint32 IIRegFsRemote_SImpl::RemoveDirWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = RemoveDir(
        strPath );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::RemoveDir(
    const std::string& strPath )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->RemoveDir(
        strPath );
}

gint32 IIRegFsRemote_SImpl::SetGidWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 wGid;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, wGid );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = SetGid(
        strPath,
        wGid );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::SetGid(
    const std::string& strPath,
    guint32 wGid )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->SetGid(
        strPath,
        wGid );
}

gint32 IIRegFsRemote_SImpl::SetUidWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 wUid;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, wUid );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = SetUid(
        strPath,
        wUid );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::SetUid(
    const std::string& strPath,
    guint32 wUid )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->SetUid(
        strPath,
        wUid );
}

gint32 IIRegFsRemote_SImpl::GetGidWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 gid;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = GetGid(
        strPath,
        gid );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, gid );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::GetGid(
    const std::string& strPath,
    guint32& gid )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->GetGid(
        strPath,
        gid );
}

gint32 IIRegFsRemote_SImpl::GetUidWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 uid;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = GetUid(
        strPath,
        uid );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, uid );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::GetUid(
    const std::string& strPath,
    guint32& uid )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->GetUid(
        strPath,
        uid );
}

gint32 IIRegFsRemote_SImpl::SymLinkWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strSrcPath;
    std::string strDestPath;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strSrcPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, strDestPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = SymLink(
        strSrcPath,
        strDestPath );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::SymLink(
    const std::string& strSrcPath,
    const std::string& strDestPath )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->SymLink(
        strSrcPath,
        strDestPath );
}

gint32 IIRegFsRemote_SImpl::GetValueWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    std::string strJson;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = GetValue(
        strPath,
        strJson );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, strJson );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::GetValue(
    const std::string& strPath,
    std::string& strJson )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->GetValue(
        strPath,
        strJson );
}

gint32 IIRegFsRemote_SImpl::SetValueWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    std::string strJson;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, strJson );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = SetValue(
        strPath,
        strJson );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::SetValue(
    const std::string& strPath,
    const std::string& strJson )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->SetValue(
        strPath,
        strJson );
}

gint32 IIRegFsRemote_SImpl::ChmodWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 dwMode;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwMode );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = Chmod(
        strPath,
        dwMode );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::Chmod(
    const std::string& strPath,
    guint32 dwMode )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->Chmod(
        strPath,
        dwMode );
}

gint32 IIRegFsRemote_SImpl::ChownWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 dwUid;
    guint32 dwGid;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwUid );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwGid );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = Chown(
        strPath,
        dwUid,
        dwGid );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::Chown(
    const std::string& strPath,
    guint32 dwUid,
    guint32 dwGid )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->Chown(
        strPath,
        dwUid,
        dwGid );
}

gint32 IIRegFsRemote_SImpl::ReadLinkWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    BufPtr buf;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = ReadLink(
        strPath,
        buf );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, buf );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::ReadLink(
    const std::string& strPath,
    BufPtr& buf )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->ReadLink(
        strPath,
        buf );
}

gint32 IIRegFsRemote_SImpl::RenameWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string szFrom;
    std::string szTo;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, szFrom );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, szTo );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = Rename(
        szFrom,
        szTo );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::Rename(
    const std::string& szFrom,
    const std::string& szTo )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->Rename(
        szFrom,
        szTo );
}

gint32 IIRegFsRemote_SImpl::FlushWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    guint32 dwFlags;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, dwFlags );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = Flush(
        dwFlags );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::Flush(
    guint32 dwFlags )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->Flush(
        dwFlags );
}

gint32 IIRegFsRemote_SImpl::AccessWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 dwFlags;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwFlags );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = Access(
        strPath,
        dwFlags );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::Access(
    const std::string& strPath,
    guint32 dwFlags )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->Access(
        strPath,
        dwFlags );
}

gint32 IIRegFsRemote_SImpl::GetAttrWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    FileStat oStat;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = GetAttr(
        strPath,
        oStat );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            oStat.SetIf( oSerial_.GetIf() );
            ret = oSerial_.SerialStruct( 
                pBuf2, oStat );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::GetAttr(
    const std::string& strPath,
    FileStat& oStat )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->GetAttr(
        strPath,
        oStat );
}

gint32 IIRegFsRemote_SImpl::ReadDirWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    guint64 hDir;
    std::vector<FileStat> vecDirEnt;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, hDir );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = ReadDir(
        hDir,
        vecDirEnt );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.SerializeArray(
                pBuf2, vecDirEnt, "(O)" );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::ReadDir(
    guint64 hDir,
    std::vector<FileStat>& vecDirEnt )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->ReadDir(
        hDir,
        vecDirEnt );
}

gint32 IIRegFsRemote_SImpl::OpenDirWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPath;
    guint32 dwFlags;
    guint64 hDir;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, dwFlags );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = OpenDir(
        strPath,
        dwFlags,
        hDir );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, hDir );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::OpenDir(
    const std::string& strPath,
    guint32 dwFlags,
    guint64& hDir )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OpenDir(
        strPath,
        dwFlags,
        hDir );
}

gint32 IIRegFsRemote_SImpl::ExecBatWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strJson;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strJson );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = ExecBat(
        strJson );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}
//RPC Sync Req Handler
gint32 IIRegFsRemote_SImpl::ExecBat(
    const std::string& strJson )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIRegFsRemote_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->ExecBat(
        strJson );
}
gint32 KeyValue::Serialize( BufPtr& pBuf_ )
{
    if( pBuf_.IsEmpty() )
        return -EINVAL;
    gint32 ret = 0;
    do{
        ret = CSerialBase::Serialize(
            pBuf_, ( ( guint32 )0x73747275 ) );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, m_dwMsgId );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, strKey );
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Serialize(
            pBuf_, oValue );
        if( ERROR( ret ) ) break;
        
    }while( 0 );

    return ret;
    
}

gint32 KeyValue::Serialize( CBuffer& oBuf_ ) const
{
    BufPtr pBuf( &oBuf_ );
    auto pThis = const_cast< KeyValue* >( this );
    guint32 dwOff = oBuf_.offset();
    gint32 ret = pThis->Serialize( pBuf );
    if( ERROR( ret ) ) return ret;
    oBuf_.SetOffset( dwOff );
    return 0;
    
}

gint32 KeyValue::Deserialize( BufPtr& pBuf_ )
{
    if( pBuf_.IsEmpty() )
        return -EINVAL;
    gint32 ret = 0;
    do{
        guint32 dwMagic;
        ret = CSerialBase::Deserialize(
            pBuf_, dwMagic );
        if( ERROR( ret ) ) break;
        if( dwMagic != ( ( guint32 )0x73747275 ) )
        {
            ret = -EBADMSG;
            break;
        }
        guint32 dwMsgId = 0;
        ret = CSerialBase::Deserialize(
            pBuf_, dwMsgId );
        if( ERROR( ret ) ) break;
        if( m_dwMsgId != dwMsgId )
        {
            ret = -EBADMSG;
            break;
        }
        ret = CSerialBase::Deserialize(
            pBuf_, strKey );
        
        if( ERROR( ret ) ) break;
        
        ret = CSerialBase::Deserialize(
            pBuf_, oValue );
        
        if( ERROR( ret ) ) break;
        
    }while( 0 );

    return ret;
    
}

gint32 KeyValue::Deserialize( const CBuffer& oBuf_ )
{
    BufPtr pBuf( const_cast< CBuffer* >( &oBuf_ ) );
    return this->Deserialize( pBuf );
}

KeyValue& KeyValue::operator=(
    const KeyValue& rhs )
{
    do{
        // data members
        if( GetObjId() == rhs.GetObjId() )
            break;
        
        strKey = rhs.strKey;
        oValue = rhs.oValue;
        
    }while( 0 );

    return *this;
}

gint32 IIAppMonitor_PImpl::InitUserFuncs()
{
    BEGIN_IFPROXY_MAP( IAppMonitor, false );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIAppMonitor_PImpl::RegisterListenerDummy,
        "RegisterListener" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIAppMonitor_PImpl::RemoveListenerDummy,
        "RemoveListener" );

    ADD_USER_PROXY_METHOD_EX( 0,
        IIAppMonitor_PImpl::ListApps,
        "ListApps" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIAppMonitor_PImpl::ListPointsDummy,
        "ListPoints" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIAppMonitor_PImpl::ListAttributesDummy,
        "ListAttributes" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIAppMonitor_PImpl::SetPointValueDummy,
        "SetPointValue" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIAppMonitor_PImpl::GetPointValueDummy,
        "GetPointValue" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIAppMonitor_PImpl::SetAttrValueDummy,
        "SetAttrValue" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIAppMonitor_PImpl::GetAttrValueDummy,
        "GetAttrValue" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIAppMonitor_PImpl::SetPointValuesDummy,
        "SetPointValues" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIAppMonitor_PImpl::GetPointValuesDummy,
        "GetPointValues" );

    END_IFPROXY_MAP;
    
    BEGIN_IFHANDLER_MAP( IAppMonitor );

    ADD_USER_EVENT_HANDLER(
        IIAppMonitor_PImpl::OnPointChangedWrapper,
        "OnPointChanged" );
    
    ADD_USER_EVENT_HANDLER(
        IIAppMonitor_PImpl::OnPointsChangedWrapper,
        "OnPointsChanged" );
    
    END_IFHANDLER_MAP;
    
    return STATUS_SUCCESS;
}

gint32 IIAppMonitor_PImpl::RegisterListener( 
    IConfigDb* context,
    HANDLE hStream_h,
    std::vector<std::string>& arrApps )
{
    gint32 ret = 0;
    TaskletPtr pRespCb_;
    do{
        CParamList oOptions_;
        CfgPtr pResp_;
        oOptions_[ propIfName ] =
            DBUS_IF_NAME( "IAppMonitor" );
        oOptions_[ propSeriProto ] = 
            ( guint32 )seriRidl;
        
        CParamList oReqCtx_;
        ObjPtr pTemp( context );
        oReqCtx_.Push( pTemp );
        
        ret = NEW_PROXY_RESP_HANDLER2(
            pRespCb_, ObjPtr( this ), 
            &IIAppMonitor_PImpl::RegisterListenerCbWrapper, 
            nullptr, oReqCtx_.GetCfg() );

        if( ERROR( ret ) ) break;
        
        //Serialize the input parameters
        BufPtr pBuf_( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        HSTREAM hStream;
        hStream.m_hStream = hStream_h;
        do{
            hStream.m_pIf = oSerial_.GetIf();
            ret = hStream.Serialize( pBuf_ );
            if( ERROR( ret ) ) break;
            
            ret = oSerial_.SerializeArray(
                pBuf_, arrApps, "(s)" );
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        
        ret = this->AsyncCall(
            ( IEventSink* )pRespCb_, 
            oOptions_.GetCfg(), pResp_,
            "RegisterListener",
            pBuf_ );
        gint32 ret2 = pRespCb_->GetError();
        if( SUCCEEDED( ret ) )
        {
            if( ret2 != STATUS_PENDING )
            {
                // pRespCb_ has been called
                ret = STATUS_PENDING;
            }
            else
            {
                // immediate return
                ( *pRespCb_ )( eventCancelTask );
                pRespCb_.Clear();
            }
        }
        if( ret == STATUS_PENDING )
        {
            if( context == nullptr )
                break;
            CCfgOpener oContext( context );
            oContext.CopyProp(
                propTaskId, pResp_ );
            break;
        }
        else if( ERROR( ret ) )
        {
            break;
        }
        // immediate return
        CCfgOpener oResp_( ( IConfigDb* )pResp_ );
        oResp_.GetIntProp(
            propReturnValue, ( guint32& )ret );
        
    }while( 0 );
    
    if( ERROR( ret ) && !pRespCb_.IsEmpty() )
        ( *pRespCb_ )( eventCancelTask );
    
    return ret;
}
//Async callback wrapper
gint32 IIAppMonitor_PImpl::RegisterListenerCbWrapper( 
    IEventSink* pCallback, 
    IEventSink* pIoReq,
    IConfigDb* pReqCtx )
{
    gint32 ret = 0;
    do{
        IConfigDb* pResp_ = nullptr;
        CCfgOpenerObj oReq_( pIoReq );
        ret = oReq_.GetPointer(
            propRespPtr, pResp_ );
        if( ERROR( ret ) )
            break;
        
        CCfgOpener oResp_( pResp_ );
        gint32 iRet = 0;
        ret = oResp_.GetIntProp( 
            propReturnValue, ( guint32& ) iRet );
        if( ERROR( ret ) ) break;

        IConfigDb* context = nullptr;
        CCfgOpener oReqCtx_( pReqCtx );
        ret = oReqCtx_.GetPointer( 0, context );
        if( ERROR( ret ) ) context = nullptr;
        
        RegisterListenerCallback( context, iRet );
        
    }while( 0 );
    
    return 0;
}
gint32 IIAppMonitor_PImpl::RegisterListenerCallback(
    IConfigDb* context, 
    gint32 iRet )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_CliApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->RegisterListenerCallback(
        context, iRet );
}

gint32 IIAppMonitor_PImpl::RemoveListener( 
    IConfigDb* context,
    HANDLE hStream_h )
{
    gint32 ret = 0;
    TaskletPtr pRespCb_;
    do{
        CParamList oOptions_;
        CfgPtr pResp_;
        oOptions_[ propIfName ] =
            DBUS_IF_NAME( "IAppMonitor" );
        oOptions_[ propSeriProto ] = 
            ( guint32 )seriRidl;
        
        CParamList oReqCtx_;
        ObjPtr pTemp( context );
        oReqCtx_.Push( pTemp );
        
        ret = NEW_PROXY_RESP_HANDLER2(
            pRespCb_, ObjPtr( this ), 
            &IIAppMonitor_PImpl::RemoveListenerCbWrapper, 
            nullptr, oReqCtx_.GetCfg() );

        if( ERROR( ret ) ) break;
        
        //Serialize the input parameters
        BufPtr pBuf_( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        HSTREAM hStream;
        hStream.m_hStream = hStream_h;
        do{
            hStream.m_pIf = oSerial_.GetIf();
            ret = hStream.Serialize( pBuf_ );
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        
        ret = this->AsyncCall(
            ( IEventSink* )pRespCb_, 
            oOptions_.GetCfg(), pResp_,
            "RemoveListener",
            pBuf_ );
        gint32 ret2 = pRespCb_->GetError();
        if( SUCCEEDED( ret ) )
        {
            if( ret2 != STATUS_PENDING )
            {
                // pRespCb_ has been called
                ret = STATUS_PENDING;
            }
            else
            {
                // immediate return
                ( *pRespCb_ )( eventCancelTask );
                pRespCb_.Clear();
            }
        }
        if( ret == STATUS_PENDING )
        {
            if( context == nullptr )
                break;
            CCfgOpener oContext( context );
            oContext.CopyProp(
                propTaskId, pResp_ );
            break;
        }
        else if( ERROR( ret ) )
        {
            break;
        }
        // immediate return
        CCfgOpener oResp_( ( IConfigDb* )pResp_ );
        oResp_.GetIntProp(
            propReturnValue, ( guint32& )ret );
        
    }while( 0 );
    
    if( ERROR( ret ) && !pRespCb_.IsEmpty() )
        ( *pRespCb_ )( eventCancelTask );
    
    return ret;
}
//Async callback wrapper
gint32 IIAppMonitor_PImpl::RemoveListenerCbWrapper( 
    IEventSink* pCallback, 
    IEventSink* pIoReq,
    IConfigDb* pReqCtx )
{
    gint32 ret = 0;
    do{
        IConfigDb* pResp_ = nullptr;
        CCfgOpenerObj oReq_( pIoReq );
        ret = oReq_.GetPointer(
            propRespPtr, pResp_ );
        if( ERROR( ret ) )
            break;
        
        CCfgOpener oResp_( pResp_ );
        gint32 iRet = 0;
        ret = oResp_.GetIntProp( 
            propReturnValue, ( guint32& ) iRet );
        if( ERROR( ret ) ) break;

        IConfigDb* context = nullptr;
        CCfgOpener oReqCtx_( pReqCtx );
        ret = oReqCtx_.GetPointer( 0, context );
        if( ERROR( ret ) ) context = nullptr;
        
        RemoveListenerCallback( context, iRet );
        
    }while( 0 );
    
    return 0;
}
gint32 IIAppMonitor_PImpl::RemoveListenerCallback(
    IConfigDb* context, 
    gint32 iRet )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_CliApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->RemoveListenerCallback(
        context, iRet );
}

gint32 IIAppMonitor_PImpl::ListApps(
    std::vector<std::string>& arrApps )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IAppMonitor" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "ListApps", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.DeserialArray(
            pBuf2, arrApps, "(s)" );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIAppMonitor_PImpl::ListPoints(
    const std::string& strAppPath,
    std::vector<std::string>& arrPoints )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IAppMonitor" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strAppPath );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "ListPoints", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.DeserialArray(
            pBuf2, arrPoints, "(s)" );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIAppMonitor_PImpl::ListAttributes(
    const std::string& strPtPath,
    std::vector<std::string>& arrAttributes )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IAppMonitor" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPtPath );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "ListAttributes", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.DeserialArray(
            pBuf2, arrAttributes, "(s)" );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIAppMonitor_PImpl::SetPointValue(
    const std::string& strPtPath,
    const Variant& value )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IAppMonitor" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPtPath );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, value );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "SetPointValue", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIAppMonitor_PImpl::GetPointValue(
    const std::string& strPtPath,
    Variant& rvalue )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IAppMonitor" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPtPath );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "GetPointValue", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.Deserialize(
            pBuf2, rvalue );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIAppMonitor_PImpl::SetAttrValue(
    const std::string& strAttrPath,
    const Variant& value )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IAppMonitor" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strAttrPath );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, value );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "SetAttrValue", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIAppMonitor_PImpl::GetAttrValue(
    const std::string& strAttrPath,
    Variant& rvalue )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IAppMonitor" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strAttrPath );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "GetAttrValue", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.Deserialize(
            pBuf2, rvalue );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIAppMonitor_PImpl::SetPointValues(
    std::vector<KeyValue>& arrValues )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IAppMonitor" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.SerializeArray(
            pBuf_, arrValues, "(O)" );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "SetPointValues", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    return ret;
}

gint32 IIAppMonitor_PImpl::GetPointValues(
    std::vector<std::string>& arrPtPaths,
    std::vector<KeyValue>& arrKeyVals )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IAppMonitor" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.SerializeArray(
            pBuf_, arrPtPaths, "(s)" );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "GetPointValues", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.DeserialArray(
            pBuf2, arrKeyVals, "(O)" );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIAppMonitor_PImpl::OnPointChangedWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strPtPath;
    Variant value;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strPtPath );
        
        if( ERROR( ret ) ) break;
        
        ret = oDeserial_.Deserialize(
            pBuf_, value );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    OnPointChanged(strPtPath,
    value );

    return ret;
}
//RPC event handler 'OnPointChanged'
gint32 IIAppMonitor_PImpl::OnPointChanged(
    const std::string& strPtPath,
    const Variant& value )
{
    gint32 ret = 0;
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_CliApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OnPointChanged(
        strPtPath,
        value );
    return ret;
}

gint32 IIAppMonitor_PImpl::OnPointsChangedWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::vector<KeyValue> arrKVs;
    
    ObjPtr pDeserialIf_(GetStreamIf());
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.DeserialArray(
            pBuf_, arrKVs, "(O)" );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    OnPointsChanged(arrKVs );

    return ret;
}
//RPC event handler 'OnPointsChanged'
gint32 IIAppMonitor_PImpl::OnPointsChanged(
    std::vector<KeyValue>& arrKVs )
{
    gint32 ret = 0;
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_CliApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OnPointsChanged(
        arrKVs );
    return ret;
}
gint32 IIAppMonitor_SImpl::InitUserFuncs()
{
    BEGIN_IFHANDLER_MAP( IAppMonitor );

    ADD_USER_SERVICE_HANDLER(
        IIAppMonitor_SImpl::RegisterListenerWrapper,
        "RegisterListener" );
    
    ADD_USER_SERVICE_HANDLER(
        IIAppMonitor_SImpl::RemoveListenerWrapper,
        "RemoveListener" );
    
    ADD_USER_SERVICE_HANDLER(
        IIAppMonitor_SImpl::ListAppsWrapper,
        "ListApps" );
    
    ADD_USER_SERVICE_HANDLER(
        IIAppMonitor_SImpl::ListPointsWrapper,
        "ListPoints" );
    
    ADD_USER_SERVICE_HANDLER(
        IIAppMonitor_SImpl::ListAttributesWrapper,
        "ListAttributes" );
    
    ADD_USER_SERVICE_HANDLER(
        IIAppMonitor_SImpl::SetPointValueWrapper,
        "SetPointValue" );
    
    ADD_USER_SERVICE_HANDLER(
        IIAppMonitor_SImpl::GetPointValueWrapper,
        "GetPointValue" );
    
    ADD_USER_SERVICE_HANDLER(
        IIAppMonitor_SImpl::SetAttrValueWrapper,
        "SetAttrValue" );
    
    ADD_USER_SERVICE_HANDLER(
        IIAppMonitor_SImpl::GetAttrValueWrapper,
        "GetAttrValue" );
    
    ADD_USER_SERVICE_HANDLER(
        IIAppMonitor_SImpl::SetPointValuesWrapper,
        "SetPointValues" );
    
    ADD_USER_SERVICE_HANDLER(
        IIAppMonitor_SImpl::GetPointValuesWrapper,
        "GetPointValues" );
    
    END_IFHANDLER_MAP;
    
    return STATUS_SUCCESS;
}

gint32 IIAppMonitor_SImpl::RegisterListenerWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    TaskletPtr pNewCb;
    do{
        ret = SetInvTimeout( pCallback, 0 );
        if( ERROR( ret ) ) break;
        CParamList oReqCtx_;
        oReqCtx_.SetPointer(
            propEventSink, pCallback );
        IConfigDb* pReqCtx_ = oReqCtx_.GetCfg();
        ret = DEFER_CANCEL_HANDLER2(
            -1, pNewCb, this,
            &IIAppMonitor_SImpl::RegisterListenerCancelWrapper,
            pCallback, 0, pReqCtx_, pBuf_ );
        
        if( ERROR( ret ) ) break;
        
        HSTREAM hStream;
        std::vector<std::string> arrApps;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            hStream.m_pIf = oDeserial_.GetIf();
            ret = hStream.Deserialize( pBuf_ );
            if( ERROR( ret ) ) break;
            
            ret = oDeserial_.DeserialArray(
                pBuf_, arrApps, "(s)" );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        ret = RegisterListener(
            pReqCtx_,
            hStream.m_hStream,
            arrApps );
        
        if( ret == STATUS_PENDING ) break;
        
        CParamList oResp_;
        oResp_[ propReturnValue ] = ret;
        oResp_[ propSeriProto ] = seriRidl;
        
        this->SetResponse( pCallback,
            oResp_.GetCfg() );
        
    }while( 0 );
    
    if( ret != STATUS_PENDING &&
        !pNewCb.IsEmpty() )
    {
        CIfRetryTask* pTask = pNewCb;
        pTask->ClearClientNotify();
        if( pCallback != nullptr )
            rpcf::RemoveInterceptCallback(
                pTask, pCallback );
        ( *pNewCb )( eventCancelTask );
    }
    return ret;
}
// this method is called when
// timeout happens or user cancels
// this pending request
gint32 IIAppMonitor_SImpl::RegisterListenerCancelWrapper(
    IEventSink* pCallback,
    gint32 iRet,
    IConfigDb* pReqCtx_, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    do{
        HSTREAM hStream;
        std::vector<std::string> arrApps;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            hStream.m_pIf = oDeserial_.GetIf();
            ret = hStream.Deserialize( pBuf_ );
            if( ERROR( ret ) ) break;
            
            ret = oDeserial_.DeserialArray(
                pBuf_, arrApps, "(s)" );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        OnRegisterListenerCanceled( pReqCtx_,
            iRet,
            hStream.m_hStream,
            arrApps );
    }while( 0 );

    return ret;
}
//RPC Async Req Cancel Handler
gint32 IIAppMonitor_SImpl::OnRegisterListenerCanceled(
    IConfigDb* pReqCtx_, gint32 iRet,
    HANDLE hStream_h,
    std::vector<std::string>& arrApps )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OnRegisterListenerCanceled(
        pReqCtx_, iRet,hStream_h,
        arrApps );
}

//RPC Async Req Handler
gint32 IIAppMonitor_SImpl::RegisterListener(
    IConfigDb* pReqCtx_,
    HANDLE hStream_h,
    std::vector<std::string>& arrApps )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->RegisterListener(
        pReqCtx_, hStream_h,
        arrApps );
}
// call me when you have completed
// the asynchronous operation
gint32 IIAppMonitor_SImpl::RegisterListenerComplete( 
    IConfigDb* pReqCtx_, gint32 iRet )
{
    gint32 ret = 0;
    IEventSink* pCallback = nullptr;
    CParamList oParams( pReqCtx_ );
    ret = oParams.GetPointer(
        propEventSink, pCallback );
    if( ERROR( ret ) )
        return ret;
    if( iRet == STATUS_PENDING )
        ret = ERROR_STATE;
    else
        ret = iRet;
    
    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->OnServiceComplete( 
        ( IConfigDb* )oResp_.GetCfg(), pCallback );
    return ret;
}

gint32 IIAppMonitor_SImpl::RemoveListenerWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    TaskletPtr pNewCb;
    do{
        ret = SetInvTimeout( pCallback, 0 );
        if( ERROR( ret ) ) break;
        CParamList oReqCtx_;
        oReqCtx_.SetPointer(
            propEventSink, pCallback );
        IConfigDb* pReqCtx_ = oReqCtx_.GetCfg();
        ret = DEFER_CANCEL_HANDLER2(
            -1, pNewCb, this,
            &IIAppMonitor_SImpl::RemoveListenerCancelWrapper,
            pCallback, 0, pReqCtx_, pBuf_ );
        
        if( ERROR( ret ) ) break;
        
        HSTREAM hStream;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            hStream.m_pIf = oDeserial_.GetIf();
            ret = hStream.Deserialize( pBuf_ );
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        ret = RemoveListener(
            pReqCtx_,
            hStream.m_hStream );
        
        if( ret == STATUS_PENDING ) break;
        
        CParamList oResp_;
        oResp_[ propReturnValue ] = ret;
        oResp_[ propSeriProto ] = seriRidl;
        
        this->SetResponse( pCallback,
            oResp_.GetCfg() );
        
    }while( 0 );
    
    if( ret != STATUS_PENDING &&
        !pNewCb.IsEmpty() )
    {
        CIfRetryTask* pTask = pNewCb;
        pTask->ClearClientNotify();
        if( pCallback != nullptr )
            rpcf::RemoveInterceptCallback(
                pTask, pCallback );
        ( *pNewCb )( eventCancelTask );
    }
    return ret;
}
// this method is called when
// timeout happens or user cancels
// this pending request
gint32 IIAppMonitor_SImpl::RemoveListenerCancelWrapper(
    IEventSink* pCallback,
    gint32 iRet,
    IConfigDb* pReqCtx_, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    do{
        HSTREAM hStream;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            hStream.m_pIf = oDeserial_.GetIf();
            ret = hStream.Deserialize( pBuf_ );
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        OnRemoveListenerCanceled( pReqCtx_,
            iRet,
            hStream.m_hStream );
    }while( 0 );

    return ret;
}
//RPC Async Req Cancel Handler
gint32 IIAppMonitor_SImpl::OnRemoveListenerCanceled(
    IConfigDb* pReqCtx_, gint32 iRet,
    HANDLE hStream_h )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OnRemoveListenerCanceled(
        pReqCtx_, iRet,hStream_h );
}

//RPC Async Req Handler
gint32 IIAppMonitor_SImpl::RemoveListener(
    IConfigDb* pReqCtx_,
    HANDLE hStream_h )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->RemoveListener(
        pReqCtx_, hStream_h );
}
// call me when you have completed
// the asynchronous operation
gint32 IIAppMonitor_SImpl::RemoveListenerComplete( 
    IConfigDb* pReqCtx_, gint32 iRet )
{
    gint32 ret = 0;
    IEventSink* pCallback = nullptr;
    CParamList oParams( pReqCtx_ );
    ret = oParams.GetPointer(
        propEventSink, pCallback );
    if( ERROR( ret ) )
        return ret;
    if( iRet == STATUS_PENDING )
        ret = ERROR_STATE;
    else
        ret = iRet;
    
    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->OnServiceComplete( 
        ( IConfigDb* )oResp_.GetCfg(), pCallback );
    return ret;
}

gint32 IIAppMonitor_SImpl::ListAppsWrapper( 
    IEventSink* pCallback )
{
    gint32 ret = 0;
    TaskletPtr pNewCb;
    do{
        ret = SetInvTimeout( pCallback, 0 );
        if( ERROR( ret ) ) break;
        CParamList oReqCtx_;
        oReqCtx_.SetPointer(
            propEventSink, pCallback );
        IConfigDb* pReqCtx_ = oReqCtx_.GetCfg();
        ret = DEFER_CANCEL_HANDLER2(
            -1, pNewCb, this,
            &IIAppMonitor_SImpl::ListAppsCancelWrapper,
            pCallback, 0, pReqCtx_ );
        
        if( ERROR( ret ) ) break;
        
        std::vector<std::string> arrApps;
        
        ret = ListApps(
            pReqCtx_,
            arrApps );
        
        if( ret == STATUS_PENDING ) break;
        
        CParamList oResp_;
        oResp_[ propReturnValue ] = ret;
        oResp_[ propSeriProto ] = seriRidl;
        if( SUCCEEDED( ret ) )
        {
            BufPtr pBuf2( true );
            
            ObjPtr pSerialIf_(GetStreamIf());
            CSerialBase oSerial_( pSerialIf_ );
            do{
                ret = oSerial_.SerializeArray(
                    pBuf2, arrApps, "(s)" );
                if( ERROR( ret ) ) break;
                
                pBuf2->SetOffset( 0 );
            }while( 0 );

            if( ERROR( ret ) )
                break;
            oResp_.Push( pBuf2 );
        }
        
        this->SetResponse( pCallback,
            oResp_.GetCfg() );
        
    }while( 0 );
    
    if( ret != STATUS_PENDING &&
        !pNewCb.IsEmpty() )
    {
        CIfRetryTask* pTask = pNewCb;
        pTask->ClearClientNotify();
        if( pCallback != nullptr )
            rpcf::RemoveInterceptCallback(
                pTask, pCallback );
        ( *pNewCb )( eventCancelTask );
    }
    return ret;
}
// this method is called when
// timeout happens or user cancels
// this pending request
gint32 IIAppMonitor_SImpl::ListAppsCancelWrapper(
    IEventSink* pCallback,
    gint32 iRet,
    IConfigDb* pReqCtx_ )
{
    gint32 ret = 0;
    do{
        OnListAppsCanceled( pReqCtx_, iRet );
    }while( 0 );

    return ret;
}
//RPC Async Req Cancel Handler
gint32 IIAppMonitor_SImpl::OnListAppsCanceled(
    IConfigDb* pReqCtx_, gint32 iRet )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OnListAppsCanceled(
        pReqCtx_, iRet );
}

//RPC Async Req Handler
gint32 IIAppMonitor_SImpl::ListApps(
    IConfigDb* pReqCtx_,
    std::vector<std::string>& arrApps )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->ListApps(
        pReqCtx_, arrApps );
}
// call me when you have completed
// the asynchronous operation
gint32 IIAppMonitor_SImpl::ListAppsComplete( 
    IConfigDb* pReqCtx_, gint32 iRet,
    std::vector<std::string>& arrApps )
{
    gint32 ret = 0;
    IEventSink* pCallback = nullptr;
    CParamList oParams( pReqCtx_ );
    ret = oParams.GetPointer(
        propEventSink, pCallback );
    if( ERROR( ret ) )
        return ret;
    if( iRet == STATUS_PENDING )
        ret = ERROR_STATE;
    else
        ret = iRet;
    
    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf_( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.SerializeArray(
                pBuf_, arrApps, "(s)" );
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf_ );
        
    }
    this->OnServiceComplete( 
        ( IConfigDb* )oResp_.GetCfg(), pCallback );
    return ret;
}

gint32 IIAppMonitor_SImpl::ListPointsWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    TaskletPtr pNewCb;
    do{
        ret = SetInvTimeout( pCallback, 0 );
        if( ERROR( ret ) ) break;
        CParamList oReqCtx_;
        oReqCtx_.SetPointer(
            propEventSink, pCallback );
        IConfigDb* pReqCtx_ = oReqCtx_.GetCfg();
        ret = DEFER_CANCEL_HANDLER2(
            -1, pNewCb, this,
            &IIAppMonitor_SImpl::ListPointsCancelWrapper,
            pCallback, 0, pReqCtx_, pBuf_ );
        
        if( ERROR( ret ) ) break;
        
        std::string strAppPath;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.Deserialize(
                pBuf_, strAppPath );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        std::vector<std::string> arrPoints;
        
        ret = ListPoints(
            pReqCtx_,
            strAppPath,
            arrPoints );
        
        if( ret == STATUS_PENDING ) break;
        
        CParamList oResp_;
        oResp_[ propReturnValue ] = ret;
        oResp_[ propSeriProto ] = seriRidl;
        if( SUCCEEDED( ret ) )
        {
            BufPtr pBuf2( true );
            
            ObjPtr pSerialIf_(GetStreamIf());
            CSerialBase oSerial_( pSerialIf_ );
            do{
                ret = oSerial_.SerializeArray(
                    pBuf2, arrPoints, "(s)" );
                if( ERROR( ret ) ) break;
                
                pBuf2->SetOffset( 0 );
            }while( 0 );

            if( ERROR( ret ) )
                break;
            oResp_.Push( pBuf2 );
        }
        
        this->SetResponse( pCallback,
            oResp_.GetCfg() );
        
    }while( 0 );
    
    if( ret != STATUS_PENDING &&
        !pNewCb.IsEmpty() )
    {
        CIfRetryTask* pTask = pNewCb;
        pTask->ClearClientNotify();
        if( pCallback != nullptr )
            rpcf::RemoveInterceptCallback(
                pTask, pCallback );
        ( *pNewCb )( eventCancelTask );
    }
    return ret;
}
// this method is called when
// timeout happens or user cancels
// this pending request
gint32 IIAppMonitor_SImpl::ListPointsCancelWrapper(
    IEventSink* pCallback,
    gint32 iRet,
    IConfigDb* pReqCtx_, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    do{
        std::string strAppPath;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.Deserialize(
                pBuf_, strAppPath );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        OnListPointsCanceled( pReqCtx_,
            iRet,
            strAppPath );
    }while( 0 );

    return ret;
}
//RPC Async Req Cancel Handler
gint32 IIAppMonitor_SImpl::OnListPointsCanceled(
    IConfigDb* pReqCtx_, gint32 iRet,
    const std::string& strAppPath )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OnListPointsCanceled(
        pReqCtx_, iRet,strAppPath );
}

//RPC Async Req Handler
gint32 IIAppMonitor_SImpl::ListPoints(
    IConfigDb* pReqCtx_,
    const std::string& strAppPath,
    std::vector<std::string>& arrPoints )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->ListPoints(
        pReqCtx_, strAppPath,
        arrPoints );
}
// call me when you have completed
// the asynchronous operation
gint32 IIAppMonitor_SImpl::ListPointsComplete( 
    IConfigDb* pReqCtx_, gint32 iRet,
    std::vector<std::string>& arrPoints )
{
    gint32 ret = 0;
    IEventSink* pCallback = nullptr;
    CParamList oParams( pReqCtx_ );
    ret = oParams.GetPointer(
        propEventSink, pCallback );
    if( ERROR( ret ) )
        return ret;
    if( iRet == STATUS_PENDING )
        ret = ERROR_STATE;
    else
        ret = iRet;
    
    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf_( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.SerializeArray(
                pBuf_, arrPoints, "(s)" );
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf_ );
        
    }
    this->OnServiceComplete( 
        ( IConfigDb* )oResp_.GetCfg(), pCallback );
    return ret;
}

gint32 IIAppMonitor_SImpl::ListAttributesWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    TaskletPtr pNewCb;
    do{
        ret = SetInvTimeout( pCallback, 0 );
        if( ERROR( ret ) ) break;
        CParamList oReqCtx_;
        oReqCtx_.SetPointer(
            propEventSink, pCallback );
        IConfigDb* pReqCtx_ = oReqCtx_.GetCfg();
        ret = DEFER_CANCEL_HANDLER2(
            -1, pNewCb, this,
            &IIAppMonitor_SImpl::ListAttributesCancelWrapper,
            pCallback, 0, pReqCtx_, pBuf_ );
        
        if( ERROR( ret ) ) break;
        
        std::string strPtPath;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.Deserialize(
                pBuf_, strPtPath );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        std::vector<std::string> arrAttributes;
        
        ret = ListAttributes(
            pReqCtx_,
            strPtPath,
            arrAttributes );
        
        if( ret == STATUS_PENDING ) break;
        
        CParamList oResp_;
        oResp_[ propReturnValue ] = ret;
        oResp_[ propSeriProto ] = seriRidl;
        if( SUCCEEDED( ret ) )
        {
            BufPtr pBuf2( true );
            
            ObjPtr pSerialIf_(GetStreamIf());
            CSerialBase oSerial_( pSerialIf_ );
            do{
                ret = oSerial_.SerializeArray(
                    pBuf2, arrAttributes, "(s)" );
                if( ERROR( ret ) ) break;
                
                pBuf2->SetOffset( 0 );
            }while( 0 );

            if( ERROR( ret ) )
                break;
            oResp_.Push( pBuf2 );
        }
        
        this->SetResponse( pCallback,
            oResp_.GetCfg() );
        
    }while( 0 );
    
    if( ret != STATUS_PENDING &&
        !pNewCb.IsEmpty() )
    {
        CIfRetryTask* pTask = pNewCb;
        pTask->ClearClientNotify();
        if( pCallback != nullptr )
            rpcf::RemoveInterceptCallback(
                pTask, pCallback );
        ( *pNewCb )( eventCancelTask );
    }
    return ret;
}
// this method is called when
// timeout happens or user cancels
// this pending request
gint32 IIAppMonitor_SImpl::ListAttributesCancelWrapper(
    IEventSink* pCallback,
    gint32 iRet,
    IConfigDb* pReqCtx_, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    do{
        std::string strPtPath;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.Deserialize(
                pBuf_, strPtPath );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        OnListAttributesCanceled( pReqCtx_,
            iRet,
            strPtPath );
    }while( 0 );

    return ret;
}
//RPC Async Req Cancel Handler
gint32 IIAppMonitor_SImpl::OnListAttributesCanceled(
    IConfigDb* pReqCtx_, gint32 iRet,
    const std::string& strPtPath )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OnListAttributesCanceled(
        pReqCtx_, iRet,strPtPath );
}

//RPC Async Req Handler
gint32 IIAppMonitor_SImpl::ListAttributes(
    IConfigDb* pReqCtx_,
    const std::string& strPtPath,
    std::vector<std::string>& arrAttributes )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->ListAttributes(
        pReqCtx_, strPtPath,
        arrAttributes );
}
// call me when you have completed
// the asynchronous operation
gint32 IIAppMonitor_SImpl::ListAttributesComplete( 
    IConfigDb* pReqCtx_, gint32 iRet,
    std::vector<std::string>& arrAttributes )
{
    gint32 ret = 0;
    IEventSink* pCallback = nullptr;
    CParamList oParams( pReqCtx_ );
    ret = oParams.GetPointer(
        propEventSink, pCallback );
    if( ERROR( ret ) )
        return ret;
    if( iRet == STATUS_PENDING )
        ret = ERROR_STATE;
    else
        ret = iRet;
    
    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf_( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.SerializeArray(
                pBuf_, arrAttributes, "(s)" );
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf_ );
        
    }
    this->OnServiceComplete( 
        ( IConfigDb* )oResp_.GetCfg(), pCallback );
    return ret;
}

gint32 IIAppMonitor_SImpl::SetPointValueWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    TaskletPtr pNewCb;
    do{
        ret = SetInvTimeout( pCallback, 0 );
        if( ERROR( ret ) ) break;
        CParamList oReqCtx_;
        oReqCtx_.SetPointer(
            propEventSink, pCallback );
        IConfigDb* pReqCtx_ = oReqCtx_.GetCfg();
        ret = DEFER_CANCEL_HANDLER2(
            -1, pNewCb, this,
            &IIAppMonitor_SImpl::SetPointValueCancelWrapper,
            pCallback, 0, pReqCtx_, pBuf_ );
        
        if( ERROR( ret ) ) break;
        
        std::string strPtPath;
        Variant value;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.Deserialize(
                pBuf_, strPtPath );
            
            if( ERROR( ret ) ) break;
            
            ret = oDeserial_.Deserialize(
                pBuf_, value );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        ret = SetPointValue(
            pReqCtx_,
            strPtPath,
            value );
        
        if( ret == STATUS_PENDING ) break;
        
        CParamList oResp_;
        oResp_[ propReturnValue ] = ret;
        oResp_[ propSeriProto ] = seriRidl;
        
        this->SetResponse( pCallback,
            oResp_.GetCfg() );
        
    }while( 0 );
    
    if( ret != STATUS_PENDING &&
        !pNewCb.IsEmpty() )
    {
        CIfRetryTask* pTask = pNewCb;
        pTask->ClearClientNotify();
        if( pCallback != nullptr )
            rpcf::RemoveInterceptCallback(
                pTask, pCallback );
        ( *pNewCb )( eventCancelTask );
    }
    return ret;
}
// this method is called when
// timeout happens or user cancels
// this pending request
gint32 IIAppMonitor_SImpl::SetPointValueCancelWrapper(
    IEventSink* pCallback,
    gint32 iRet,
    IConfigDb* pReqCtx_, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    do{
        std::string strPtPath;
        Variant value;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.Deserialize(
                pBuf_, strPtPath );
            
            if( ERROR( ret ) ) break;
            
            ret = oDeserial_.Deserialize(
                pBuf_, value );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        OnSetPointValueCanceled( pReqCtx_,
            iRet,
            strPtPath,
            value );
    }while( 0 );

    return ret;
}
//RPC Async Req Cancel Handler
gint32 IIAppMonitor_SImpl::OnSetPointValueCanceled(
    IConfigDb* pReqCtx_, gint32 iRet,
    const std::string& strPtPath,
    const Variant& value )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OnSetPointValueCanceled(
        pReqCtx_, iRet,strPtPath,
        value );
}

//RPC Async Req Handler
gint32 IIAppMonitor_SImpl::SetPointValue(
    IConfigDb* pReqCtx_,
    const std::string& strPtPath,
    const Variant& value )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->SetPointValue(
        pReqCtx_, strPtPath,
        value );
}
// call me when you have completed
// the asynchronous operation
gint32 IIAppMonitor_SImpl::SetPointValueComplete( 
    IConfigDb* pReqCtx_, gint32 iRet )
{
    gint32 ret = 0;
    IEventSink* pCallback = nullptr;
    CParamList oParams( pReqCtx_ );
    ret = oParams.GetPointer(
        propEventSink, pCallback );
    if( ERROR( ret ) )
        return ret;
    if( iRet == STATUS_PENDING )
        ret = ERROR_STATE;
    else
        ret = iRet;
    
    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->OnServiceComplete( 
        ( IConfigDb* )oResp_.GetCfg(), pCallback );
    return ret;
}

gint32 IIAppMonitor_SImpl::GetPointValueWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    TaskletPtr pNewCb;
    do{
        ret = SetInvTimeout( pCallback, 0 );
        if( ERROR( ret ) ) break;
        CParamList oReqCtx_;
        oReqCtx_.SetPointer(
            propEventSink, pCallback );
        IConfigDb* pReqCtx_ = oReqCtx_.GetCfg();
        ret = DEFER_CANCEL_HANDLER2(
            -1, pNewCb, this,
            &IIAppMonitor_SImpl::GetPointValueCancelWrapper,
            pCallback, 0, pReqCtx_, pBuf_ );
        
        if( ERROR( ret ) ) break;
        
        std::string strPtPath;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.Deserialize(
                pBuf_, strPtPath );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        Variant rvalue;
        
        ret = GetPointValue(
            pReqCtx_,
            strPtPath,
            rvalue );
        
        if( ret == STATUS_PENDING ) break;
        
        CParamList oResp_;
        oResp_[ propReturnValue ] = ret;
        oResp_[ propSeriProto ] = seriRidl;
        if( SUCCEEDED( ret ) )
        {
            BufPtr pBuf2( true );
            
            ObjPtr pSerialIf_(GetStreamIf());
            CSerialBase oSerial_( pSerialIf_ );
            do{
                ret = oSerial_.Serialize(
                    pBuf2, rvalue );
                if( ERROR( ret ) ) break;
                
                pBuf2->SetOffset( 0 );
            }while( 0 );

            if( ERROR( ret ) )
                break;
            oResp_.Push( pBuf2 );
        }
        
        this->SetResponse( pCallback,
            oResp_.GetCfg() );
        
    }while( 0 );
    
    if( ret != STATUS_PENDING &&
        !pNewCb.IsEmpty() )
    {
        CIfRetryTask* pTask = pNewCb;
        pTask->ClearClientNotify();
        if( pCallback != nullptr )
            rpcf::RemoveInterceptCallback(
                pTask, pCallback );
        ( *pNewCb )( eventCancelTask );
    }
    return ret;
}
// this method is called when
// timeout happens or user cancels
// this pending request
gint32 IIAppMonitor_SImpl::GetPointValueCancelWrapper(
    IEventSink* pCallback,
    gint32 iRet,
    IConfigDb* pReqCtx_, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    do{
        std::string strPtPath;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.Deserialize(
                pBuf_, strPtPath );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        OnGetPointValueCanceled( pReqCtx_,
            iRet,
            strPtPath );
    }while( 0 );

    return ret;
}
//RPC Async Req Cancel Handler
gint32 IIAppMonitor_SImpl::OnGetPointValueCanceled(
    IConfigDb* pReqCtx_, gint32 iRet,
    const std::string& strPtPath )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OnGetPointValueCanceled(
        pReqCtx_, iRet,strPtPath );
}

//RPC Async Req Handler
gint32 IIAppMonitor_SImpl::GetPointValue(
    IConfigDb* pReqCtx_,
    const std::string& strPtPath,
    Variant& rvalue )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->GetPointValue(
        pReqCtx_, strPtPath,
        rvalue );
}
// call me when you have completed
// the asynchronous operation
gint32 IIAppMonitor_SImpl::GetPointValueComplete( 
    IConfigDb* pReqCtx_, gint32 iRet,
    const Variant& rvalue )
{
    gint32 ret = 0;
    IEventSink* pCallback = nullptr;
    CParamList oParams( pReqCtx_ );
    ret = oParams.GetPointer(
        propEventSink, pCallback );
    if( ERROR( ret ) )
        return ret;
    if( iRet == STATUS_PENDING )
        ret = ERROR_STATE;
    else
        ret = iRet;
    
    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf_( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf_, rvalue );
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf_ );
        
    }
    this->OnServiceComplete( 
        ( IConfigDb* )oResp_.GetCfg(), pCallback );
    return ret;
}

gint32 IIAppMonitor_SImpl::SetAttrValueWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    TaskletPtr pNewCb;
    do{
        ret = SetInvTimeout( pCallback, 0 );
        if( ERROR( ret ) ) break;
        CParamList oReqCtx_;
        oReqCtx_.SetPointer(
            propEventSink, pCallback );
        IConfigDb* pReqCtx_ = oReqCtx_.GetCfg();
        ret = DEFER_CANCEL_HANDLER2(
            -1, pNewCb, this,
            &IIAppMonitor_SImpl::SetAttrValueCancelWrapper,
            pCallback, 0, pReqCtx_, pBuf_ );
        
        if( ERROR( ret ) ) break;
        
        std::string strAttrPath;
        Variant value;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.Deserialize(
                pBuf_, strAttrPath );
            
            if( ERROR( ret ) ) break;
            
            ret = oDeserial_.Deserialize(
                pBuf_, value );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        ret = SetAttrValue(
            pReqCtx_,
            strAttrPath,
            value );
        
        if( ret == STATUS_PENDING ) break;
        
        CParamList oResp_;
        oResp_[ propReturnValue ] = ret;
        oResp_[ propSeriProto ] = seriRidl;
        
        this->SetResponse( pCallback,
            oResp_.GetCfg() );
        
    }while( 0 );
    
    if( ret != STATUS_PENDING &&
        !pNewCb.IsEmpty() )
    {
        CIfRetryTask* pTask = pNewCb;
        pTask->ClearClientNotify();
        if( pCallback != nullptr )
            rpcf::RemoveInterceptCallback(
                pTask, pCallback );
        ( *pNewCb )( eventCancelTask );
    }
    return ret;
}
// this method is called when
// timeout happens or user cancels
// this pending request
gint32 IIAppMonitor_SImpl::SetAttrValueCancelWrapper(
    IEventSink* pCallback,
    gint32 iRet,
    IConfigDb* pReqCtx_, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    do{
        std::string strAttrPath;
        Variant value;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.Deserialize(
                pBuf_, strAttrPath );
            
            if( ERROR( ret ) ) break;
            
            ret = oDeserial_.Deserialize(
                pBuf_, value );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        OnSetAttrValueCanceled( pReqCtx_,
            iRet,
            strAttrPath,
            value );
    }while( 0 );

    return ret;
}
//RPC Async Req Cancel Handler
gint32 IIAppMonitor_SImpl::OnSetAttrValueCanceled(
    IConfigDb* pReqCtx_, gint32 iRet,
    const std::string& strAttrPath,
    const Variant& value )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OnSetAttrValueCanceled(
        pReqCtx_, iRet,strAttrPath,
        value );
}

//RPC Async Req Handler
gint32 IIAppMonitor_SImpl::SetAttrValue(
    IConfigDb* pReqCtx_,
    const std::string& strAttrPath,
    const Variant& value )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->SetAttrValue(
        pReqCtx_, strAttrPath,
        value );
}
// call me when you have completed
// the asynchronous operation
gint32 IIAppMonitor_SImpl::SetAttrValueComplete( 
    IConfigDb* pReqCtx_, gint32 iRet )
{
    gint32 ret = 0;
    IEventSink* pCallback = nullptr;
    CParamList oParams( pReqCtx_ );
    ret = oParams.GetPointer(
        propEventSink, pCallback );
    if( ERROR( ret ) )
        return ret;
    if( iRet == STATUS_PENDING )
        ret = ERROR_STATE;
    else
        ret = iRet;
    
    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->OnServiceComplete( 
        ( IConfigDb* )oResp_.GetCfg(), pCallback );
    return ret;
}

gint32 IIAppMonitor_SImpl::GetAttrValueWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    TaskletPtr pNewCb;
    do{
        ret = SetInvTimeout( pCallback, 0 );
        if( ERROR( ret ) ) break;
        CParamList oReqCtx_;
        oReqCtx_.SetPointer(
            propEventSink, pCallback );
        IConfigDb* pReqCtx_ = oReqCtx_.GetCfg();
        ret = DEFER_CANCEL_HANDLER2(
            -1, pNewCb, this,
            &IIAppMonitor_SImpl::GetAttrValueCancelWrapper,
            pCallback, 0, pReqCtx_, pBuf_ );
        
        if( ERROR( ret ) ) break;
        
        std::string strAttrPath;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.Deserialize(
                pBuf_, strAttrPath );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        Variant rvalue;
        
        ret = GetAttrValue(
            pReqCtx_,
            strAttrPath,
            rvalue );
        
        if( ret == STATUS_PENDING ) break;
        
        CParamList oResp_;
        oResp_[ propReturnValue ] = ret;
        oResp_[ propSeriProto ] = seriRidl;
        if( SUCCEEDED( ret ) )
        {
            BufPtr pBuf2( true );
            
            ObjPtr pSerialIf_(GetStreamIf());
            CSerialBase oSerial_( pSerialIf_ );
            do{
                ret = oSerial_.Serialize(
                    pBuf2, rvalue );
                if( ERROR( ret ) ) break;
                
                pBuf2->SetOffset( 0 );
            }while( 0 );

            if( ERROR( ret ) )
                break;
            oResp_.Push( pBuf2 );
        }
        
        this->SetResponse( pCallback,
            oResp_.GetCfg() );
        
    }while( 0 );
    
    if( ret != STATUS_PENDING &&
        !pNewCb.IsEmpty() )
    {
        CIfRetryTask* pTask = pNewCb;
        pTask->ClearClientNotify();
        if( pCallback != nullptr )
            rpcf::RemoveInterceptCallback(
                pTask, pCallback );
        ( *pNewCb )( eventCancelTask );
    }
    return ret;
}
// this method is called when
// timeout happens or user cancels
// this pending request
gint32 IIAppMonitor_SImpl::GetAttrValueCancelWrapper(
    IEventSink* pCallback,
    gint32 iRet,
    IConfigDb* pReqCtx_, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    do{
        std::string strAttrPath;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.Deserialize(
                pBuf_, strAttrPath );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        OnGetAttrValueCanceled( pReqCtx_,
            iRet,
            strAttrPath );
    }while( 0 );

    return ret;
}
//RPC Async Req Cancel Handler
gint32 IIAppMonitor_SImpl::OnGetAttrValueCanceled(
    IConfigDb* pReqCtx_, gint32 iRet,
    const std::string& strAttrPath )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OnGetAttrValueCanceled(
        pReqCtx_, iRet,strAttrPath );
}

//RPC Async Req Handler
gint32 IIAppMonitor_SImpl::GetAttrValue(
    IConfigDb* pReqCtx_,
    const std::string& strAttrPath,
    Variant& rvalue )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->GetAttrValue(
        pReqCtx_, strAttrPath,
        rvalue );
}
// call me when you have completed
// the asynchronous operation
gint32 IIAppMonitor_SImpl::GetAttrValueComplete( 
    IConfigDb* pReqCtx_, gint32 iRet,
    const Variant& rvalue )
{
    gint32 ret = 0;
    IEventSink* pCallback = nullptr;
    CParamList oParams( pReqCtx_ );
    ret = oParams.GetPointer(
        propEventSink, pCallback );
    if( ERROR( ret ) )
        return ret;
    if( iRet == STATUS_PENDING )
        ret = ERROR_STATE;
    else
        ret = iRet;
    
    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf_( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf_, rvalue );
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf_ );
        
    }
    this->OnServiceComplete( 
        ( IConfigDb* )oResp_.GetCfg(), pCallback );
    return ret;
}

gint32 IIAppMonitor_SImpl::SetPointValuesWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    TaskletPtr pNewCb;
    do{
        ret = SetInvTimeout( pCallback, 0 );
        if( ERROR( ret ) ) break;
        CParamList oReqCtx_;
        oReqCtx_.SetPointer(
            propEventSink, pCallback );
        IConfigDb* pReqCtx_ = oReqCtx_.GetCfg();
        ret = DEFER_CANCEL_HANDLER2(
            -1, pNewCb, this,
            &IIAppMonitor_SImpl::SetPointValuesCancelWrapper,
            pCallback, 0, pReqCtx_, pBuf_ );
        
        if( ERROR( ret ) ) break;
        
        std::vector<KeyValue> arrValues;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.DeserialArray(
                pBuf_, arrValues, "(O)" );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        ret = SetPointValues(
            pReqCtx_,
            arrValues );
        
        if( ret == STATUS_PENDING ) break;
        
        CParamList oResp_;
        oResp_[ propReturnValue ] = ret;
        oResp_[ propSeriProto ] = seriRidl;
        
        this->SetResponse( pCallback,
            oResp_.GetCfg() );
        
    }while( 0 );
    
    if( ret != STATUS_PENDING &&
        !pNewCb.IsEmpty() )
    {
        CIfRetryTask* pTask = pNewCb;
        pTask->ClearClientNotify();
        if( pCallback != nullptr )
            rpcf::RemoveInterceptCallback(
                pTask, pCallback );
        ( *pNewCb )( eventCancelTask );
    }
    return ret;
}
// this method is called when
// timeout happens or user cancels
// this pending request
gint32 IIAppMonitor_SImpl::SetPointValuesCancelWrapper(
    IEventSink* pCallback,
    gint32 iRet,
    IConfigDb* pReqCtx_, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    do{
        std::vector<KeyValue> arrValues;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.DeserialArray(
                pBuf_, arrValues, "(O)" );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        OnSetPointValuesCanceled( pReqCtx_,
            iRet,
            arrValues );
    }while( 0 );

    return ret;
}
//RPC Async Req Cancel Handler
gint32 IIAppMonitor_SImpl::OnSetPointValuesCanceled(
    IConfigDb* pReqCtx_, gint32 iRet,
    std::vector<KeyValue>& arrValues )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OnSetPointValuesCanceled(
        pReqCtx_, iRet,arrValues );
}

//RPC Async Req Handler
gint32 IIAppMonitor_SImpl::SetPointValues(
    IConfigDb* pReqCtx_,
    std::vector<KeyValue>& arrValues )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->SetPointValues(
        pReqCtx_, arrValues );
}
// call me when you have completed
// the asynchronous operation
gint32 IIAppMonitor_SImpl::SetPointValuesComplete( 
    IConfigDb* pReqCtx_, gint32 iRet )
{
    gint32 ret = 0;
    IEventSink* pCallback = nullptr;
    CParamList oParams( pReqCtx_ );
    ret = oParams.GetPointer(
        propEventSink, pCallback );
    if( ERROR( ret ) )
        return ret;
    if( iRet == STATUS_PENDING )
        ret = ERROR_STATE;
    else
        ret = iRet;
    
    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    
    this->OnServiceComplete( 
        ( IConfigDb* )oResp_.GetCfg(), pCallback );
    return ret;
}

gint32 IIAppMonitor_SImpl::GetPointValuesWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    TaskletPtr pNewCb;
    do{
        ret = SetInvTimeout( pCallback, 0 );
        if( ERROR( ret ) ) break;
        CParamList oReqCtx_;
        oReqCtx_.SetPointer(
            propEventSink, pCallback );
        IConfigDb* pReqCtx_ = oReqCtx_.GetCfg();
        ret = DEFER_CANCEL_HANDLER2(
            -1, pNewCb, this,
            &IIAppMonitor_SImpl::GetPointValuesCancelWrapper,
            pCallback, 0, pReqCtx_, pBuf_ );
        
        if( ERROR( ret ) ) break;
        
        std::vector<std::string> arrPtPaths;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.DeserialArray(
                pBuf_, arrPtPaths, "(s)" );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        std::vector<KeyValue> arrKeyVals;
        
        ret = GetPointValues(
            pReqCtx_,
            arrPtPaths,
            arrKeyVals );
        
        if( ret == STATUS_PENDING ) break;
        
        CParamList oResp_;
        oResp_[ propReturnValue ] = ret;
        oResp_[ propSeriProto ] = seriRidl;
        if( SUCCEEDED( ret ) )
        {
            BufPtr pBuf2( true );
            
            ObjPtr pSerialIf_(GetStreamIf());
            CSerialBase oSerial_( pSerialIf_ );
            do{
                ret = oSerial_.SerializeArray(
                    pBuf2, arrKeyVals, "(O)" );
                if( ERROR( ret ) ) break;
                
                pBuf2->SetOffset( 0 );
            }while( 0 );

            if( ERROR( ret ) )
                break;
            oResp_.Push( pBuf2 );
        }
        
        this->SetResponse( pCallback,
            oResp_.GetCfg() );
        
    }while( 0 );
    
    if( ret != STATUS_PENDING &&
        !pNewCb.IsEmpty() )
    {
        CIfRetryTask* pTask = pNewCb;
        pTask->ClearClientNotify();
        if( pCallback != nullptr )
            rpcf::RemoveInterceptCallback(
                pTask, pCallback );
        ( *pNewCb )( eventCancelTask );
    }
    return ret;
}
// this method is called when
// timeout happens or user cancels
// this pending request
gint32 IIAppMonitor_SImpl::GetPointValuesCancelWrapper(
    IEventSink* pCallback,
    gint32 iRet,
    IConfigDb* pReqCtx_, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    do{
        std::vector<std::string> arrPtPaths;
        
        ObjPtr pDeserialIf_(GetStreamIf());
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf_->offset();
            ret = oDeserial_.DeserialArray(
                pBuf_, arrPtPaths, "(s)" );
            
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        OnGetPointValuesCanceled( pReqCtx_,
            iRet,
            arrPtPaths );
    }while( 0 );

    return ret;
}
//RPC Async Req Cancel Handler
gint32 IIAppMonitor_SImpl::OnGetPointValuesCanceled(
    IConfigDb* pReqCtx_, gint32 iRet,
    std::vector<std::string>& arrPtPaths )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->OnGetPointValuesCanceled(
        pReqCtx_, iRet,arrPtPaths );
}

//RPC Async Req Handler
gint32 IIAppMonitor_SImpl::GetPointValues(
    IConfigDb* pReqCtx_,
    std::vector<std::string>& arrPtPaths,
    std::vector<KeyValue>& arrKeyVals )
{
    auto& pIf = GetParentIf();
    if( pIf.IsEmpty() )
        return -EFAULT;
    CRpcServices* pSvc = pIf;
    auto pApi = dynamic_cast< IIAppMonitor_SvrApi* >( pSvc );
    if( pApi == nullptr )
        return -EFAULT;
    return pApi->GetPointValues(
        pReqCtx_, arrPtPaths,
        arrKeyVals );
}
// call me when you have completed
// the asynchronous operation
gint32 IIAppMonitor_SImpl::GetPointValuesComplete( 
    IConfigDb* pReqCtx_, gint32 iRet,
    std::vector<KeyValue>& arrKeyVals )
{
    gint32 ret = 0;
    IEventSink* pCallback = nullptr;
    CParamList oParams( pReqCtx_ );
    ret = oParams.GetPointer(
        propEventSink, pCallback );
    if( ERROR( ret ) )
        return ret;
    if( iRet == STATUS_PENDING )
        ret = ERROR_STATE;
    else
        ret = iRet;
    
    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf_( true );
        
        ObjPtr pSerialIf_(GetStreamIf());
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.SerializeArray(
                pBuf_, arrKeyVals, "(O)" );
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf_ );
        
    }
    this->OnServiceComplete( 
        ( IConfigDb* )oResp_.GetCfg(), pCallback );
    return ret;
}

gint32 IIAppMonitor_SImpl::OnPointChanged(
    const std::string& strPtPath,
    const Variant& value )
{
    gint32 ret = 0;
    CParamList oOptions_;
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strPtPath );
        if( ERROR( ret ) ) break;
        
        ret = oSerial_.Serialize(
            pBuf_, value );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    ret = this->SendEventEx(
        nullptr, oOptions_.GetCfg(),
        iid( IAppMonitor ), 
        USER_EVENT( "OnPointChanged" ), "",
        pBuf_ );

    return ret;
}

gint32 IIAppMonitor_SImpl::OnPointsChanged(
    std::vector<KeyValue>& arrKVs )
{
    gint32 ret = 0;
    CParamList oOptions_;
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(GetStreamIf());
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.SerializeArray(
            pBuf_, arrKVs, "(O)" );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    ret = this->SendEventEx(
        nullptr, oOptions_.GetCfg(),
        iid( IAppMonitor ), 
        USER_EVENT( "OnPointsChanged" ), "",
        pBuf_ );

    return ret;
}
