# GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
# Copyright (C) 2024  zhiming <woodhead99@gmail.com>
# This program can be distributed under the terms of the GNU GPLv3.
# ridlc -pO . -l regfs.ridl 
from typing import Tuple
from rpcf.rpcbase import *
from rpcf.proxy import *
from seribase import CSerialBase
from RegistryFsstructs import *
import errno

class IIRegFsLocal_CliImpl :

    _ifName_ = "IRegFsLocal"
    def CreateFile( self, 
        strPath : str,
        dwMode : int,
        dwFlags : int
        ) -> Tuple[ int, list ] :
        
        '''
        the response parameters includes
        hFile : int
        '''
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            osb.SerialInt32( buf, dwMode )
            osb.SerialInt32( buf, dwFlags )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "CreateFile" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        ret = self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        if ret[ 0 ] < 0 :
            return ret
        buf = ret[ 1 ][ 0 ]
        if buf is None or not isinstance( buf, bytearray ) : 
            return [ -errno.EBADMSG, None ] 
        
        rmtret = ret
        offset = 0
        listRet = []
        ret = osb.DeserialInt64( buf, offset )
        if ret[ 0 ] is None :
            return [ -errno.EBADMSG, None ]
        listRet.append( ret[ 0 ] )
        offset = ret[ 1 ]
        
        if len( rmtret ) == 3:
            return [ 0, listRet, rmtret ]
        return [ 0, listRet ]
        
    def MakeDir( self, 
        strPath : str,
        dwMode : int
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            osb.SerialInt32( buf, dwMode )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "MakeDir" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def OpenFile( self, 
        strPath : str,
        dwFlags : int
        ) -> Tuple[ int, list ] :
        
        '''
        the response parameters includes
        hFile : int
        '''
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            osb.SerialInt32( buf, dwFlags )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "OpenFile" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        ret = self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        if ret[ 0 ] < 0 :
            return ret
        buf = ret[ 1 ][ 0 ]
        if buf is None or not isinstance( buf, bytearray ) : 
            return [ -errno.EBADMSG, None ] 
        
        rmtret = ret
        offset = 0
        listRet = []
        ret = osb.DeserialInt64( buf, offset )
        if ret[ 0 ] is None :
            return [ -errno.EBADMSG, None ]
        listRet.append( ret[ 0 ] )
        offset = ret[ 1 ]
        
        if len( rmtret ) == 3:
            return [ 0, listRet, rmtret ]
        return [ 0, listRet ]
        
    def CloseFile( self, 
        hFile : int
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialInt64( buf, hFile )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "CloseFile" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def RemoveFile( self, 
        strPath : str
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "RemoveFile" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def ReadFile( self, 
        hFile : int,
        dwSize : int,
        dwOff : int
        ) -> Tuple[ int, list ] :
        
        '''
        the response parameters includes
        buffer : bytearray
        '''
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialInt64( buf, hFile )
            osb.SerialInt32( buf, dwSize )
            osb.SerialInt32( buf, dwOff )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "ReadFile" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        ret = self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        if ret[ 0 ] < 0 :
            return ret
        buf = ret[ 1 ][ 0 ]
        if buf is None or not isinstance( buf, bytearray ) : 
            return [ -errno.EBADMSG, None ] 
        
        rmtret = ret
        offset = 0
        listRet = []
        ret = osb.DeserialBuf( buf, offset )
        if ret[ 0 ] is None :
            return [ -errno.EBADMSG, None ]
        listRet.append( ret[ 0 ] )
        offset = ret[ 1 ]
        
        if len( rmtret ) == 3:
            return [ 0, listRet, rmtret ]
        return [ 0, listRet ]
        
    def WriteFile( self, 
        hFile : int,
        buffer : bytearray,
        dwOff : int
        ) -> Tuple[ int, list ] :
        
        '''
        the response parameters includes
        dwSizeWrite : int
        '''
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialInt64( buf, hFile )
            osb.SerialBuf( buf, buffer )
            osb.SerialInt32( buf, dwOff )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "WriteFile" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        ret = self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        if ret[ 0 ] < 0 :
            return ret
        buf = ret[ 1 ][ 0 ]
        if buf is None or not isinstance( buf, bytearray ) : 
            return [ -errno.EBADMSG, None ] 
        
        rmtret = ret
        offset = 0
        listRet = []
        ret = osb.DeserialInt32( buf, offset )
        if ret[ 0 ] is None :
            return [ -errno.EBADMSG, None ]
        listRet.append( ret[ 0 ] )
        offset = ret[ 1 ]
        
        if len( rmtret ) == 3:
            return [ 0, listRet, rmtret ]
        return [ 0, listRet ]
        
    def Truncate( self, 
        hFile : int,
        dwOff : int
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialInt64( buf, hFile )
            osb.SerialInt32( buf, dwOff )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "Truncate" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def CloseDir( self, 
        hFile : int
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialInt64( buf, hFile )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "CloseDir" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def RemoveDir( self, 
        strPath : str
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "RemoveDir" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def SetGid( self, 
        strPath : str,
        wGid : int
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            osb.SerialInt32( buf, wGid )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "SetGid" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def SetUid( self, 
        strPath : str,
        wUid : int
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            osb.SerialInt32( buf, wUid )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "SetUid" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def GetGid( self, 
        strPath : str
        ) -> Tuple[ int, list ] :
        
        '''
        the response parameters includes
        gid : int
        '''
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "GetGid" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        ret = self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        if ret[ 0 ] < 0 :
            return ret
        buf = ret[ 1 ][ 0 ]
        if buf is None or not isinstance( buf, bytearray ) : 
            return [ -errno.EBADMSG, None ] 
        
        rmtret = ret
        offset = 0
        listRet = []
        ret = osb.DeserialInt32( buf, offset )
        if ret[ 0 ] is None :
            return [ -errno.EBADMSG, None ]
        listRet.append( ret[ 0 ] )
        offset = ret[ 1 ]
        
        if len( rmtret ) == 3:
            return [ 0, listRet, rmtret ]
        return [ 0, listRet ]
        
    def GetUid( self, 
        strPath : str
        ) -> Tuple[ int, list ] :
        
        '''
        the response parameters includes
        uid : int
        '''
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "GetUid" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        ret = self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        if ret[ 0 ] < 0 :
            return ret
        buf = ret[ 1 ][ 0 ]
        if buf is None or not isinstance( buf, bytearray ) : 
            return [ -errno.EBADMSG, None ] 
        
        rmtret = ret
        offset = 0
        listRet = []
        ret = osb.DeserialInt32( buf, offset )
        if ret[ 0 ] is None :
            return [ -errno.EBADMSG, None ]
        listRet.append( ret[ 0 ] )
        offset = ret[ 1 ]
        
        if len( rmtret ) == 3:
            return [ 0, listRet, rmtret ]
        return [ 0, listRet ]
        
    def SymLink( self, 
        strSrcPath : str,
        strDestPath : str
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strSrcPath )
            osb.SerialString( buf, strDestPath )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "SymLink" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def GetValue( self, 
        strPath : str
        ) -> Tuple[ int, list ] :
        
        '''
        the response parameters includes
        strJson : str
        '''
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "GetValue" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        ret = self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        if ret[ 0 ] < 0 :
            return ret
        buf = ret[ 1 ][ 0 ]
        if buf is None or not isinstance( buf, bytearray ) : 
            return [ -errno.EBADMSG, None ] 
        
        rmtret = ret
        offset = 0
        listRet = []
        ret = osb.DeserialString( buf, offset )
        if ret[ 0 ] is None :
            return [ -errno.EBADMSG, None ]
        listRet.append( ret[ 0 ] )
        offset = ret[ 1 ]
        
        if len( rmtret ) == 3:
            return [ 0, listRet, rmtret ]
        return [ 0, listRet ]
        
    def SetValue( self, 
        strPath : str,
        strJson : str
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            osb.SerialString( buf, strJson )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "SetValue" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def Chmod( self, 
        strPath : str,
        dwMode : int
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            osb.SerialInt32( buf, dwMode )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "Chmod" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def Chown( self, 
        strPath : str,
        dwUid : int,
        dwGid : int
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            osb.SerialInt32( buf, dwUid )
            osb.SerialInt32( buf, dwGid )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "Chown" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def ReadLink( self, 
        strPath : str
        ) -> Tuple[ int, list ] :
        
        '''
        the response parameters includes
        buf : bytearray
        '''
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "ReadLink" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        ret = self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        if ret[ 0 ] < 0 :
            return ret
        buf = ret[ 1 ][ 0 ]
        if buf is None or not isinstance( buf, bytearray ) : 
            return [ -errno.EBADMSG, None ] 
        
        rmtret = ret
        offset = 0
        listRet = []
        ret = osb.DeserialBuf( buf, offset )
        if ret[ 0 ] is None :
            return [ -errno.EBADMSG, None ]
        listRet.append( ret[ 0 ] )
        offset = ret[ 1 ]
        
        if len( rmtret ) == 3:
            return [ 0, listRet, rmtret ]
        return [ 0, listRet ]
        
    def Rename( self, 
        szFrom : str,
        szTo : str
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, szFrom )
            osb.SerialString( buf, szTo )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "Rename" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def Flush( self, 
        dwFlags : int
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialInt32( buf, dwFlags )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "Flush" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def Access( self, 
        strPath : str,
        dwFlags : int
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            osb.SerialInt32( buf, dwFlags )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "Access" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    def GetAttr( self, 
        strPath : str
        ) -> Tuple[ int, list ] :
        
        '''
        the response parameters includes
        oStat : FileStat
        '''
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "GetAttr" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        ret = self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        if ret[ 0 ] < 0 :
            return ret
        buf = ret[ 1 ][ 0 ]
        if buf is None or not isinstance( buf, bytearray ) : 
            return [ -errno.EBADMSG, None ] 
        
        rmtret = ret
        offset = 0
        listRet = []
        ret = osb.DeserialStruct( buf, offset )
        if ret[ 0 ] is None :
            return [ -errno.EBADMSG, None ]
        listRet.append( ret[ 0 ] )
        offset = ret[ 1 ]
        
        if len( rmtret ) == 3:
            return [ 0, listRet, rmtret ]
        return [ 0, listRet ]
        
    def ReadDir( self, 
        hDir : int
        ) -> Tuple[ int, list ] :
        
        '''
        the response parameters includes
        vecDirEnt : (FileStat)
        '''
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialInt64( buf, hDir )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "ReadDir" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        ret = self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        if ret[ 0 ] < 0 :
            return ret
        buf = ret[ 1 ][ 0 ]
        if buf is None or not isinstance( buf, bytearray ) : 
            return [ -errno.EBADMSG, None ] 
        
        rmtret = ret
        offset = 0
        listRet = []
        ret = osb.DeserialArray( buf, offset, "(O)" )
        if ret[ 0 ] is None :
            return [ -errno.EBADMSG, None ]
        listRet.append( ret[ 0 ] )
        offset = ret[ 1 ]
        
        if len( rmtret ) == 3:
            return [ 0, listRet, rmtret ]
        return [ 0, listRet ]
        
    def OpenDir( self, 
        strPath : str,
        dwFlags : int
        ) -> Tuple[ int, list ] :
        
        '''
        the response parameters includes
        hDir : int
        '''
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strPath )
            osb.SerialInt32( buf, dwFlags )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "OpenDir" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        ret = self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        if ret[ 0 ] < 0 :
            return ret
        buf = ret[ 1 ][ 0 ]
        if buf is None or not isinstance( buf, bytearray ) : 
            return [ -errno.EBADMSG, None ] 
        
        rmtret = ret
        offset = 0
        listRet = []
        ret = osb.DeserialInt64( buf, offset )
        if ret[ 0 ] is None :
            return [ -errno.EBADMSG, None ]
        listRet.append( ret[ 0 ] )
        offset = ret[ 1 ]
        
        if len( rmtret ) == 3:
            return [ 0, listRet, rmtret ]
        return [ 0, listRet ]
        
    def ExecBat( self, 
        strJson : str
        ) -> Tuple[ int, list ] :
        
        osb = CSerialBase( self )
        buf = bytearray()
        ret = 0
        while True:
        
            osb.SerialString( buf, strJson )
            break
            
        listArgs = [ buf, ]
        #preparing the options
        oOptions = cpp.CParamList()
        oOptions.SetStrProp( cpp.propIfName, IIRegFsLocal_CliImpl._ifName_ )
        oOptions.SetStrProp( cpp.propMethodName, "ExecBat" )
        oOptions.SetIntProp( cpp.propSeriProto, cpp.seriRidl )
        listResp = [ None, None ]
        return self.MakeCallWithOpt( 
            oOptions.GetCfg(), listArgs, listResp )
        
    
